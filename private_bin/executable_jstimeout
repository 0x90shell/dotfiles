#!/usr/bin/env python3
'''
Script to automatically disable the bluetooth gamepad when 
there is no activity for a specified time. It matches /dev/input 
with bluetooth mac addresses for DS3 controllers to force a BT disconnect.
This is necessary, because DS3 timeout cannot be configured without a PS3
due to a proprietary timeout implementation by Sony.

Modify maxidletime to be appropriate.
Modify specfic_names list to include any other controllers that need monitoring.

Ðœake the script executable and add it to autorun in desktop mode 
or better yet a systemctl service to recover it if it crashes.

################################################################
######                 Service Setup                      ######
################################################################
------
File |
------
~/.config/systemd/user/jstimeout.service     
[Unit]
Description=jslisten daemon
After=network.target auditd.service

[Service]
ExecStartPre=/bin/sleep 10
Type=idle
ExecStart=/home/gandalf/bin/jstimeout
Restart=on-failure

[Install]
WantedBy=default.target

----------
Commands |
----------
systemctl daemon-reload
systemctl enable --user jstimeout.service
systemctl start --user jstimeout.service

'''

import struct
from datetime import datetime as dt
import sys, os
import select
import time
from threading import Thread, Event

# Maximum idle time in seconds (60 minutes)
#maxidletime = 3600
maxidletime = 60

# List of known devices to query from /proc/bus/input/devices
specific_names = ["Sony PLAYSTATION(R)3 Controller", "Sony Computer Entertainment Wireless Controller"]

# Dictionary to keep track of running threads by their uniq identifier and dev path
running_threads = {}

# Function to parse /proc/bus/input/devices and return matching devices with "js" handler and uniq field
def parse_input_devices(specific_names):
    devices = []
    current_device = {}
    
    try:
        with open("/proc/bus/input/devices", "r") as f:
            for line in f:
                line = line.strip()
                
                # Identify the device name
                if line.startswith("N: Name="):
                    device_name = line.split('=')[1].strip('"')
                    current_device['name'] = device_name
                
                # Identify the uniq field
                elif line.startswith("U: Uniq="):
                    uniq = line.split('=')[1].strip()
                    current_device['uniq'] = uniq
                
                # Identify the handler
                elif line.startswith("H: Handlers="):
                    handlers = line.split('=')[1].strip().split()
                    current_device['handlers'] = handlers
                
                # End of a device block, add to list if it matches specific names and has "js" in handlers
                elif line == "":
                    if ('name' in current_device and 
                        current_device['name'] in specific_names and
                        'uniq' in current_device and
                        any("js" in handler for handler in current_device['handlers'])):
                        devices.append(current_device)
                    current_device = {}

        return devices
    
    except FileNotFoundError:
        print("Error: Unable to open /proc/bus/input/devices. Are you running this on a system with /proc available?")
        return []

# Input checker function that listens for device events
def input_checker(dev, uniq_and_dev):
    try:
        while os.path.exists(dev):
            while True:
                time.sleep(10) #moved from 1s to 10s sleep to reduce cpu overhead
                EVENT_SIZE = struct.calcsize("llHHI")
                file = open(dev, "rb")
                break
                
            while True:
                r, w, e = select.select([file], [], [], 0)
                if file in r:
                    try:
                        event = file.read(EVENT_SIZE)
                        print(struct.unpack("llHHI", event))
                        movement.set()
                        print("movement detected")
                    except:
                        break
                else:
                    pass
    finally:
        # Clean up and remove from running_threads when done
        if uniq_and_dev in running_threads:
            del running_threads[uniq_and_dev]

# Timer function to disconnect device if idle for too long
def timer(devid, maxidletime, dev, uniq_and_dev):
    currtime = dt.now()
    prevtime = currtime
    try:
        while True:
            time.sleep(10) #moved from 1s to 10s sleep to reduce cpu overhead
            currtime = dt.now()
            if os.path.exists(dev):
                if movement.is_set():
                    print("date updated")
                    prevtime = currtime
                    movement.clear()
                if (currtime - prevtime).total_seconds() >= maxidletime:
                    print(f"Device {devid} has been idle for {maxidletime} seconds, disconnecting...")
                    os.system(f"echo disconnect {devid} | bluetoothctl")
                    time.sleep(1)
                    os.system("echo exit | bluetoothctl")
                    sys.exit()
            else:
                sys.exit()
    finally:
        # Clean up and remove from running_threads when done
        if uniq_and_dev in running_threads:
            del running_threads[uniq_and_dev]

# Main function to initiate threads for matching devices
def start_threads_for_devices(devices):
    global running_threads

    for device in devices:
        for handler in device['handlers']:
            if handler.startswith('js'):  # Ensure the handler is a joystick
                dev_path = f"/dev/input/{handler}"
                uniq_and_dev = (device['uniq'], dev_path)

                # Check if a thread is already running for this device's uniq and dev_path
                if uniq_and_dev not in running_threads:
                    print(f"Starting threads for device: {device['name']} (Handler: {dev_path}, Uniq: {device['uniq']})")
                    
                    # Start input checker thread
                    t1 = Thread(target=input_checker, args=(dev_path, uniq_and_dev))
                    t1.start()
                    
                    # Start timer thread
                    t2 = Thread(target=timer, args=(device['uniq'], maxidletime, dev_path, uniq_and_dev))
                    t2.start()

                    # Track the running threads by (uniq, dev_path)
                    running_threads[uniq_and_dev] = {'input_checker': t1, 'timer': t2}

# Periodically query for new devices and start threads if needed
def query_devices_periodically():
    global running_threads
    while True:
        devices = parse_input_devices(specific_names)
        
        if devices:
            start_threads_for_devices(devices)
        else:
            print(f"No devices found matching names: {specific_names}")
        
        # Check for new devices every 5 seconds
        time.sleep(30) #modifed from 5s to 30s to reduce cpu cycles

# Event to track movement
movement = Event()

# Start querying devices in a loop
query_devices_periodically()
