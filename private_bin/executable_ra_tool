#!/usr/bin/env python3
"""
RetroAchievements ROM Compatibility Tool

Features:
- Pull hash databases for any/all RA-supported systems
- Hash local ROMs using RAHasher for all systems (handles CHD, headers, disc formats)
- Auto-pull if cache missing or older than 6 months
- Compare local collection against RA database
- Generate compatibility reports

Usage:
  ra_tool.py systems                     # List all RA systems with IDs
  ra_tool.py pull <system_id|all>        # Download hash DB for system(s)
  ra_tool.py check <system_id> <rom_dir> # Check ROMs against cached DB
  ra_tool.py hash <system_id> <file>     # Hash a single file

Environment:
  RA_API_KEY  - Your RetroAchievements Web API Key (required for pull)
  RA_HASHER   - Path to RAHasher executable (default: searches PATH)

Author: Generated for Zach's ROM management workflow
"""

import argparse
import hashlib
import json
import os
import re
import shutil
import subprocess
import sys
import tempfile
import time

import urllib.request
import urllib.error
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional
import zipfile

try:
    from tqdm import tqdm
    TQDM_AVAILABLE = True
except ImportError:
    TQDM_AVAILABLE = False

try:
    import py7zr
    PY7ZR_AVAILABLE = True
except ImportError:
    PY7ZR_AVAILABLE = False

# ============================================================================
# CONFIGURATION
# ============================================================================

# Default cache directory
CACHE_DIR = Path.home() / ".cache" / "ra_tool"

# Cache expiry in days (6 months)
CACHE_EXPIRY_DAYS = 180

# ============================================================================
# ROM FILE EXTENSIONS - Comprehensive support for No-Intro, Redump, and more
# ============================================================================

# --- Nintendo Cartridge Extensions ---
NINTENDO_CART_EXTENSIONS = (
    # NES / Famicom
    '.nes',    # Standard iNES/NES 2.0 format
    '.unf',    # UNIF format (Universal NES Image Format)
    '.unif',   # UNIF format alternate
    '.fds',    # Famicom Disk System
    # SNES / Super Famicom
    '.sfc',    # Super Famicom (No-Intro standard)
    '.smc',    # Super Magicom (copier format with header)
    '.fig',    # Pro Fighter / Super Magicom
    '.swc',    # Super Wild Card
    '.bs',     # Satellaview (SNES addon)
    '.st',     # Sufami Turbo (SNES addon)
    # Game Boy family
    '.gb',     # Game Boy
    '.gbc',    # Game Boy Color
    '.cgb',    # Game Boy Color (alternate extension)
    '.sgb',    # Super Game Boy
    '.gba',    # Game Boy Advance
    '.agb',    # Game Boy Advance (alternate)
    '.mb',     # GBA Multiboot
    # Nintendo 64 / 64DD
    '.n64',    # N64 (byte-swapped)
    '.z64',    # N64 (big endian - native format)
    '.v64',    # N64 (little endian)
    '.ndd',    # 64DD disk image
    # Nintendo DS / DSi
    '.nds',    # Nintendo DS ROM
    '.dsi',    # DSi ROM / DSi-Enhanced
    '.srl',    # DS ROM (alternate)
    '.ids',    # iQue DS
    '.app',    # DS app (used in some contexts)
    # Nintendo 3DS
    '.3ds',    # 3DS cartridge dump
    '.cia',    # 3DS installable title
    '.3dsx',   # 3DS homebrew
    '.cci',    # CTR Card Image (3DS cartridge)
    '.cxi',    # CTR Executable Image (3DS executable)
    # Virtual Boy
    '.vb',     # Virtual Boy
    '.vboy',   # Virtual Boy (alternate)
    # Pokemon Mini
    '.min',    # Pokemon Mini
)

# --- Nintendo Disc Extensions (GameCube, Wii, Wii U) ---
NINTENDO_DISC_EXTENSIONS = (
    # GameCube
    '.gcm',    # GC Master disc image (Redump standard)
    '.gcz',    # Dolphin compressed GC
    '.dol',    # GC/Wii executable (homebrew)
    '.tgc',    # Embedded GC game
    # Wii
    '.wbfs',   # Wii Backup File System
    '.wad',    # Wii installable channel/game
    '.wdf',    # Wii Disc Format (compressed)
    '.wia',    # Wii/GC compressed (Dolphin)
    '.rvz',    # Wii/GC compressed (Dolphin, improved)
    # Wii U
    '.wua',    # Wii U Archive (Cemu)
    '.rpx',    # Wii U executable
    '.wud',    # Wii U Disc
    '.wux',    # Wii U Disc (compressed)
    # Switch
    '.nsp',    # Switch installable title
    '.xci',    # Switch cartridge dump
    '.nro',    # Switch homebrew
    '.nsz',    # Switch compressed
)

# --- Sega Cartridge Extensions ---
SEGA_CART_EXTENSIONS = (
    # SG-1000
    '.sg',     # SG-1000
    # Master System
    '.sms',    # Master System
    # Game Gear
    '.gg',     # Game Gear
    # Genesis / Mega Drive
    '.md',     # Mega Drive (No-Intro standard)
    '.gen',    # Genesis (common US extension)
    '.smd',    # Super Magic Drive (copier format)
    '.sgd',    # Mega Drive (alternate)
    '.68k',    # Mega Drive (raw 68K binary)
    '.bin',    # Generic binary (also used by Genesis - context dependent)
    # Sega 32X
    '.32x',    # Sega 32X
)

# --- Sega Disc Extensions ---
SEGA_DISC_EXTENSIONS = (
    # Sega CD / Mega CD
    # (uses standard disc formats: .cue, .iso, .chd, .bin)
    # Saturn
    # (uses standard disc formats: .cue, .iso, .chd, .bin)
    # Dreamcast
    '.gdi',    # Dreamcast GD-ROM disc image
    '.cdi',    # DiscJuggler image (common for DC)
)

# --- Sony Cartridge/ROM Extensions ---
SONY_ROM_EXTENSIONS = (
    # PS Vita
    '.vpk',    # Vita installable package
    '.mai',    # Vita DLC/update
    # NOTE: PSP .pbp moved to SONY_DISC_EXTENSIONS - it contains disc images
)

# --- Sony Disc Extensions ---
SONY_DISC_EXTENSIONS = (
    # PSP
    '.pbp',    # PSP EBOOT.PBP (contains disc image inside)
    # PS3 specific
    '.pkg',    # PS3 installable package
    '.self',   # PS3 executable
    '.eboot',  # PS3/PSP executable
    # NOTE: PSX, PS2, PS3 primarily use standard disc formats in DISC_EXTENSIONS
    # (.iso, .bin, .cue, .chd)
)

# --- Microsoft Extensions ---
MICROSOFT_EXTENSIONS = (
    # Original Xbox
    '.xbe',    # Xbox executable
    '.xiso',   # Xbox ISO (specific format)
    # Xbox 360
    '.xex',    # Xbox 360 executable (NOTE: also used by Atari 800)
    '.god',    # Games on Demand
    '.live',   # Xbox Live Arcade
)

# --- NEC PC Engine / TurboGrafx Extensions ---
NEC_EXTENSIONS = (
    '.pce',    # PC Engine / TurboGrafx-16
    '.sgx',    # SuperGrafx
    '.hcd',    # PC Engine CD (hint file)
)

# --- SNK Extensions ---
SNK_EXTENSIONS = (
    '.neo',    # Neo Geo (newer dump format)
    '.ngp',    # Neo Geo Pocket
    '.ngc',    # Neo Geo Pocket Color
)

# --- Atari Extensions ---
ATARI_EXTENSIONS = (
    # Atari 2600
    '.a26',    # Atari 2600
    # Atari 5200
    '.a52',    # Atari 5200
    # Atari 7800
    '.a78',    # Atari 7800
    # Atari Lynx
    '.lnx',    # Atari Lynx
    # Atari Jaguar
    '.j64',    # Atari Jaguar
    '.jag',    # Atari Jaguar (alternate)
    # Atari 8-bit computers (800/XL/XE)
    '.atr',    # Atari 8-bit disk image
    '.xex',    # Atari 8-bit executable (conflicts with Xbox 360)
    '.xfd',    # Atari 8-bit disk image
    '.dcm',    # Atari 8-bit compressed disk
    '.cas',    # Atari 8-bit cassette
    '.car',    # Atari 8-bit cartridge
    # Atari ST
    '.st',     # Atari ST disk (NOTE: also used by Sufami Turbo)
    '.msa',    # Atari ST compressed disk
    '.stx',    # Atari ST extended disk
    '.tos',    # Atari ST system
)

# --- Other Consoles Extensions ---
OTHER_CONSOLE_EXTENSIONS = (
    # ColecoVision
    '.col',    # ColecoVision
    # Intellivision
    '.int',    # Intellivision
    # Odyssey 2
    '.o2',     # Odyssey 2 / Videopac
    # Vectrex
    '.vec',    # Vectrex
    # WonderSwan
    '.ws',     # WonderSwan
    '.wsc',    # WonderSwan Color
    '.pc2',    # WonderSwan (alternate, based on CPU)
    # NOTE: .3do moved to DISC_EXTENSIONS - 3DO is disc-based
    # Fairchild Channel F
    '.chf',    # Channel F
    # Watara Supervision
    '.sv',     # Supervision
    # NOTE: .bin is handled separately as a context-dependent format
)

# --- Computer Extensions ---
COMPUTER_EXTENSIONS = (
    # MSX
    '.rom',    # MSX cartridge (generic)
    '.mx1',    # MSX1
    '.mx2',    # MSX2
    # Commodore 64
    '.d64',    # C64 disk image (1541)
    '.t64',    # C64 tape image
    '.tap',    # C64/Spectrum tape
    '.crt',    # C64 cartridge
    '.prg',    # C64 program
    '.g64',    # C64 GCR disk image
    # ZX Spectrum
    '.z80',    # Spectrum snapshot
    '.tzx',    # Spectrum tape
    '.sna',    # Spectrum snapshot
    # Amstrad CPC
    '.dsk',    # Amstrad CPC / MSX disk
    '.cdt',    # Amstrad CPC tape
    # BBC Micro
    '.ssd',    # BBC Micro single-sided disk
    '.dsd',    # BBC Micro double-sided disk
    # Apple II
    '.do',     # Apple II DOS order
    '.po',     # Apple II ProDOS order
    '.woz',    # Apple II WOZ format (flux-level)
    '.2mg',    # Apple II 2IMG format
    '.nib',    # Apple II nibble format
    # PC-88
    '.d88',    # PC-88 disk image
    # PC-98
    '.hdm',    # PC-98 hard disk image
    '.fdi',    # PC-98 floppy disk image
    # Sharp X68000
    '.xdf',    # X68000 disk image
    '.dim',    # X68000 disk image
    # FM Towns
    '.fmtowns',  # FM Towns (rare extension)
)

# --- Fantasy Console Extensions ---
FANTASY_CONSOLE_EXTENSIONS = (
    '.p8',     # PICO-8 cartridge
    '.tic',    # TIC-80 cartridge
)

# --- Arcade Extensions ---
ARCADE_EXTENSIONS = (
    # MAME/FBNeo typically use .zip containing multiple ROM files
    # Individual ROM chips don't have standard extensions
    # CHD is used for hard drive/CD content in arcade
)

# ============================================================================
# DISC IMAGE EXTENSIONS (require special handling by RAHasher)
# ============================================================================

# Core disc formats used across multiple systems
# Console-specific formats are in NINTENDO_DISC_EXTENSIONS, SEGA_DISC_EXTENSIONS, etc.
DISC_EXTENSIONS = (
    # Standard disc image formats (used by PSX, PS2, Saturn, Sega CD, etc.)
    '.cue',    # Cue sheet (points to .bin)
    '.iso',    # ISO 9660 disc image
    '.bin',    # Binary disc image (usually paired with .cue, also cartridge for some)
    '.chd',    # MAME compressed disc (supports CD, DVD, GD-ROM, etc.)
    '.img',    # Raw disc image
    '.mdf',    # Alcohol 120% disc image
    '.ccd',    # CloneCD control file
    '.nrg',    # Nero disc image
    '.ecm',    # Error Code Modeler compressed
    # Multi-disc playlist
    '.m3u',    # Playlist for multi-disc games
    # Compressed ISO (not PSP-specific CSO which is in UNSUPPORTED)
    '.ciso',   # Compressed ISO (general purpose)
    # 3DO (disc-based console)
    '.3do',    # 3DO disc image
)

# ============================================================================
# UNSUPPORTED/COMPRESSED FORMATS (need decompression before RAHasher)
# ============================================================================

# These compressed disc formats are NOT directly supported by RAHasher.
# They must be decompressed to ISO/BIN first, or used with an emulator
# that handles decompression on-the-fly.
UNSUPPORTED_DISC_FORMATS = (
    # PSP compressed formats
    '.cso',    # Compressed ISO (PSP) - common but NOT RAHasher supported
    '.zso',    # ZISO compressed ISO
    '.dax',    # DAX compressed ISO
    '.jso',    # JISO compressed ISO
    # Other compressed formats that may need handling
    '.rar',    # RAR archive (not directly supported)
)

# ============================================================================
# ARCHIVE EXTENSIONS (RAHasher can handle ZIP internally for many systems)
# ============================================================================

ARCHIVE_EXTENSIONS = (
    '.zip',    # ZIP archive - RAHasher handles for most cartridge systems
    '.7z',     # 7-Zip archive - may need extraction
)

# ============================================================================
# COMBINED EXTENSION LISTS
# ============================================================================

# All cartridge/ROM extensions (non-disc)
CARTRIDGE_EXTENSIONS = (
    NINTENDO_CART_EXTENSIONS +
    SEGA_CART_EXTENSIONS +
    SONY_ROM_EXTENSIONS +
    NEC_EXTENSIONS +
    SNK_EXTENSIONS +
    ATARI_EXTENSIONS +
    OTHER_CONSOLE_EXTENSIONS +
    COMPUTER_EXTENSIONS +
    FANTASY_CONSOLE_EXTENSIONS
)

# All ROM extensions including discs and archives
ALL_ROM_EXTENSIONS = (
    CARTRIDGE_EXTENSIONS +
    DISC_EXTENSIONS +
    NINTENDO_DISC_EXTENSIONS +
    SEGA_DISC_EXTENSIONS +
    SONY_DISC_EXTENSIONS +
    MICROSOFT_EXTENSIONS +
    ARCHIVE_EXTENSIONS +
    UNSUPPORTED_DISC_FORMATS
)

# Match threshold for fuzzy comparison (0-100)
COMPARE_MATCH_THRESHOLD = 75

# Default ROM base directory for comparison
DEFAULT_ROM_BASE = Path.home() / 'mnt' / 'NAS' / 'Gamer' / 'Roms'

# Platform mapping: missing file prefix -> ROM folder name
PLATFORM_TO_FOLDER = {
    'n64': 'n64', 'psx': 'psx', 'gc': 'gc', 'snes': 'SNES', 'nes': 'NES',
    'gba': 'GBA', 'nds': 'nds', '3ds': '3DS', 'dreamcast': 'dreamcast',
    'saturn': 'SS', 'ps2': 'ps2', 'wii': 'wii', 'gamecube': 'gc',
    'genesis': 'Genesis', 'gb': 'GB', 'gbc': 'GBC', 'psp': 'PSP',
}

# ============================================================================
# SYSTEMS REQUIRING RAHASHER
# ============================================================================

# Systems that REQUIRE RAHasher for accurate hashing:
# - Disc-based systems (need sector-level hashing, CHD extraction)
# - Systems with special headers (need header detection/removal)
# - Systems with complex ROM layouts
#
# RAHasher performs console-specific hash algorithms that differ from simple MD5.
# For disc-based systems, it extracts and hashes specific tracks/data sectors.

RAHASHER_REQUIRED = {
    # --- Systems with special header handling ---
    7,   # NES - needs iNES/NES 2.0 header removal
    13,  # Atari Lynx - has header that needs detection

    # --- CD-based systems (use track/sector hashing) ---
    12,  # PlayStation (PSX)
    21,  # PlayStation 2
    41,  # PlayStation Portable (PSP)
    56,  # Mega CD / Sega CD
    39,  # Sega Saturn
    40,  # Sega Dreamcast
    76,  # PC Engine CD / TurboGrafx-CD
    77,  # Atari Jaguar CD
    49,  # PC-FX
    43,  # 3DO Interactive Multiplayer

    # --- Optical/disc-based newer systems ---
    # These require RAHasher for proper disc image handling:
    16,  # GameCube (mini-DVD based)
    19,  # Wii (DVD based)
    # Note: Wii U and Switch don't have official RA support yet but may need special handling

    # --- Systems with complex ROM structures ---
    # Neo Geo CD, etc. if they use disc images

    # --- N64 DD (disk-based addon) ---
    # Uses system ID 2 (N64) but .ndd files need special handling
}

# Additional notes for RAHasher behavior:
# - For CHD files: RAHasher extracts and hashes the relevant data
# - For CUE/BIN: Hashes track 1 data or specific sectors based on system
# - For M3U (multi-disc): Hashes first disc
# - For archives: Extracts and hashes contents (ZIP supported for most systems)
# - For PSP PBP: Extracts and hashes the ISO inside

# ============================================================================
# TITLE CATEGORIZATION
# ============================================================================


def categorize_title(title: str) -> tuple:
    """Categorize an RA title by type.

    Returns (category, base_title) where category is one of:
    - 'base': Official/retail games
    - 'hack': ROM hacks (~Hack~ prefix)
    - 'homebrew': Homebrew games (~Homebrew~ prefix)
    - 'subset': Achievement subsets ([Subset - X] suffix)
    - 'special': Other special titles (demos, prototypes, etc.)
    """
    if '[Subset' in title:
        # Extract base game name: "Game Name [Subset - X]" -> "Game Name"
        base = title.split('[Subset')[0].strip()
        return ('subset', base)
    elif title.startswith('~Hack~'):
        return ('hack', title)
    elif title.startswith('~Homebrew~'):
        return ('homebrew', title)
    elif title.startswith('~'):  # Other special (demos, prototypes, etc.)
        return ('special', title)
    else:
        return ('base', title)


# System name aliases - maps common names to system ID
# These are used for user-friendly lookups
SYSTEM_ALIASES = {
    # === Nintendo Home Consoles ===
    'nes': 7, 'famicom': 7, 'fc': 7, 'nintendo': 7,
    'fds': 7,  # FDS uses NES system ID in RA
    'snes': 3, 'super nintendo': 3, 'super famicom': 3, 'sfc': 3, 'super nes': 3,
    'satellaview': 3, 'bs-x': 3,  # Satellaview uses SNES ID
    'n64': 2, 'nintendo 64': 2, 'nintendo64': 2,
    '64dd': 2,  # 64DD uses N64 system ID
    'gc': 16, 'gamecube': 16, 'ngc': 16, 'nintendo gamecube': 16,
    'wii': 19, 'nintendo wii': 19,
    # Note: Wii U (101) and Switch don't have full RA support yet

    # === Nintendo Handhelds ===
    'gb': 4, 'game boy': 4, 'gameboy': 4,
    'gbc': 6, 'game boy color': 6, 'gameboy color': 6,
    'gba': 5, 'game boy advance': 5, 'gameboy advance': 5,
    'vb': 28, 'virtual boy': 28, 'virtualboy': 28,
    'nds': 18, 'ds': 18, 'nintendo ds': 18,
    'dsi': 18,  # DSi uses DS system ID
    '3ds': 78, 'n3ds': 78, 'nintendo 3ds': 78,
    'pokemon mini': 24, 'pokemini': 24, 'pm': 24,

    # === Sega Home Consoles ===
    'sg1000': 33, 'sg-1000': 33, 'sg 1000': 33,
    'sms': 11, 'master system': 11, 'mastersystem': 11, 'sega master system': 11,
    'genesis': 1, 'mega drive': 1, 'megadrive': 1, 'md': 1, 'sega genesis': 1,
    '32x': 10, 'sega 32x': 10, 'super 32x': 10, 'mega 32x': 10,
    'sega cd': 56, 'mega cd': 56, 'segacd': 56, 'megacd': 56, 'mcd': 56,
    'saturn': 39, 'sega saturn': 39,
    'dreamcast': 40, 'dc': 40, 'sega dreamcast': 40,

    # === Sega Handhelds ===
    'gg': 15, 'game gear': 15, 'gamegear': 15, 'sega game gear': 15,

    # === Sony ===
    'ps1': 12, 'psx': 12, 'playstation': 12, 'playstation 1': 12, 'psone': 12,
    'ps2': 21, 'playstation 2': 21, 'playstation2': 21,
    'psp': 41, 'playstation portable': 41,
    # Note: PS Vita (63), PS3 (not supported with achievements)

    # === NEC / PC Engine / TurboGrafx ===
    'pce': 8, 'pc engine': 8, 'pcengine': 8, 'turbografx': 8, 'tg16': 8,
    'turbografx-16': 8, 'turbografx 16': 8,
    'supergrafx': 8, 'sgx': 8,  # SuperGrafx uses PCE ID
    'pce cd': 76, 'pc engine cd': 76, 'turbografx cd': 76, 'pcecd': 76,
    'pcfx': 49, 'pc-fx': 49, 'pc fx': 49,

    # === SNK / Neo Geo ===
    'neogeo': 14, 'neo geo': 14, 'ng': 14, 'aes': 14, 'mvs': 14,
    'neo geo cd': 56, 'neogeocd': 56, 'ngcd': 56,  # Check actual ID
    'ngp': 14, 'neo geo pocket': 14, 'neogeopocket': 14,  # Check actual ID
    'ngpc': 14, 'neo geo pocket color': 14,  # Check actual ID

    # === Atari ===
    'atari 2600': 25, '2600': 25, 'a2600': 25, 'vcs': 25, 'atari2600': 25,
    'atari 5200': 79, '5200': 79, 'a5200': 79, 'atari5200': 79,
    'atari 7800': 51, '7800': 51, 'a7800': 51, 'atari7800': 51,
    'lynx': 13, 'atari lynx': 13, 'atarilynx': 13,
    'jaguar': 17, 'atari jaguar': 17, 'atarijaguar': 17, 'jag': 17,
    'jaguar cd': 77, 'jaguarcd': 77,
    'atari st': 42, 'atarist': 42, 'st': 42,
    'atari 800': 25,  # Check actual ID - might share with 2600 or separate

    # === Other Consoles ===
    '3do': 43, '3do interactive': 43,
    'coleco': 44, 'colecovision': 44, 'coleco vision': 44,
    'intellivision': 45, 'intv': 45,
    'vectrex': 46, 'gce vectrex': 46,
    'odyssey2': 23, 'odyssey 2': 23, 'o2': 23, 'videopac': 23,
    'channel f': 57, 'fairchild': 57, 'fairchild channel f': 57,

    # === WonderSwan ===
    'wonderswan': 53, 'ws': 53,
    'wonderswancolor': 53, 'wsc': 53, 'wonderswan color': 53,  # Uses same ID

    # === Computers ===
    'msx': 29, 'msx1': 29,
    'msx2': 29,  # Shares ID with MSX
    'apple2': 38, 'apple ii': 38, 'appleii': 38, 'apple 2': 38,
    'c64': 37, 'commodore 64': 37, 'commodore64': 37,
    'zx spectrum': 80, 'zxspectrum': 80, 'spectrum': 80, 'speccy': 80,
    'amstrad cpc': 47, 'amstradcpc': 47, 'cpc': 47,
    'pc8800': 47,  # Check actual ID
    'pc9800': 47,  # Check actual ID

    # === Arcade ===
    'arcade': 27,

    # === Fantasy Consoles ===
    # Note: PICO-8 and TIC-80 may not have RA support
}

# Reverse mapping: system ID -> canonical short name (for filenames)
SYSTEM_ID_TO_NAME = {
    # Nintendo
    7: 'nes', 3: 'snes', 2: 'n64', 16: 'gc', 19: 'wii',
    4: 'gb', 6: 'gbc', 5: 'gba', 28: 'vb', 18: 'nds', 78: '3ds', 24: 'pokemini',
    # Sega
    33: 'sg1000', 11: 'sms', 1: 'genesis', 10: '32x', 56: 'segacd',
    39: 'saturn', 40: 'dreamcast',
    # Sony
    12: 'psx', 21: 'ps2', 41: 'psp',
    # Atari
    25: 'atari2600', 51: 'atari7800', 77: 'atarilynx', 17: 'atarijaguar',
    # NEC
    8: 'pce', 76: 'pcfx',
    # SNK
    14: 'neogeo', 80: 'ngp',  # Note: 56 is Sega CD, Neo Geo CD TBD
    # Other
    46: 'vectrex', 23: 'odyssey2', 57: 'channelf',
    53: 'wonderswan', 29: 'msx', 38: 'apple2', 37: 'c64', 47: 'amstrad',
    27: 'arcade',
}


# ============================================================================
# SYSTEMS CACHE
# ============================================================================


def get_systems_cache_path() -> Path:
    """Get path to systems cache file."""
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    return CACHE_DIR / "ra_systems.json"


def load_systems_cache() -> Optional[dict]:
    """Load systems cache if valid."""
    cache_path = get_systems_cache_path()
    if not cache_path.exists():
        return None

    try:
        with open(cache_path) as f:
            cached = json.load(f)

        # Check expiry (30 days for systems - they rarely change)
        cached_at = datetime.fromisoformat(cached['cached_at'])
        if datetime.now() - cached_at > timedelta(days=30):
            return None

        return cached
    except (json.JSONDecodeError, KeyError, ValueError):
        return None


def save_systems_cache(systems: list) -> dict:
    """Save systems to cache and build lookup tables."""
    # Build lookups
    by_id = {}
    by_name = {}

    for s in systems:
        sid = s.get('ID')
        name = s.get('Name', '')
        by_id[sid] = {'id': sid, 'name': name}
        # Lowercase name for lookup
        by_name[name.lower()] = sid

    cached = {
        'cached_at': datetime.now().isoformat(),
        'systems': systems,
        'by_id': by_id,
        'by_name': by_name,
    }

    cache_path = get_systems_cache_path()
    with open(cache_path, 'w') as f:
        json.dump(cached, f)

    return cached


def ensure_systems_cache(force: bool = False) -> dict:
    """Ensure systems cache exists, fetch if needed."""
    if not force:
        cached = load_systems_cache()
        if cached:
            return cached

    print("Fetching systems list from RetroAchievements...", file=sys.stderr)
    systems = fetch_systems()
    return save_systems_cache(systems)


def resolve_system_id(system_arg: str) -> int:
    """
    Resolve a system argument to its numeric ID.
    Accepts: numeric ID, system name, or alias.
    Returns system ID or exits with error.
    """
    # Try as numeric ID first
    try:
        return int(system_arg)
    except ValueError:
        pass

    # Normalize input
    normalized = system_arg.lower().strip()

    # Check hardcoded aliases first (faster, no API needed)
    if normalized in SYSTEM_ALIASES:
        return SYSTEM_ALIASES[normalized]

    # Check cached system names
    cached = ensure_systems_cache()
    by_name = cached.get('by_name', {})

    if normalized in by_name:
        return by_name[normalized]

    # Fuzzy match - check if input is contained in any system name
    for name, sid in by_name.items():
        if normalized in name or name in normalized:
            return sid

    # Not found - show available systems
    print(f"Error: Unknown system '{system_arg}'", file=sys.stderr)
    print("Use 'ra_tool.py systems' to see available systems", file=sys.stderr)
    print("Common examples: snes, genesis, nes, psx, gba, n64", file=sys.stderr)
    sys.exit(1)


def get_system_name(system_id: int) -> str:
    """Get canonical short name for a system ID (for filenames)."""
    if system_id in SYSTEM_ID_TO_NAME:
        return SYSTEM_ID_TO_NAME[system_id]
    # Fallback to numeric ID if unknown
    return str(system_id)


# ============================================================================
# COMPARE FUNCTIONS (fuzzy matching missing list against local ROMs)
# ============================================================================


def normalize_title_for_compare(title: str) -> str:
    """Normalize a title for fuzzy matching comparison."""
    s = title

    # Remove RA-specific prefixes
    s = re.sub(r'^~(Hack|Homebrew|Prototype|Demo|Unlicensed)~\s*', '', s, flags=re.IGNORECASE)

    # Remove [Subset - ...] suffix
    s = re.sub(r'\s*\[Subset\s*-[^\]]+\]', '', s, flags=re.IGNORECASE)

    # Remove region codes like (USA), (Japan), (Europe), (En,Fr,De), etc.
    s = re.sub(r'\s*\([^)]*\)', '', s)

    # Remove revision markers like (Rev 1), (Rev A)
    s = re.sub(r'\s*\(Rev\s*\w+\)', '', s, flags=re.IGNORECASE)

    # Remove disc markers like [D1], [D2], (Disc 1)
    s = re.sub(r'\s*\[D\d+\]', '', s, flags=re.IGNORECASE)
    s = re.sub(r'\s*\(Disc\s*\d+\)', '', s, flags=re.IGNORECASE)

    # Remove file extensions
    s = re.sub(r'\.(chd|7z|zip|rvz|z64|n64|v64|m3u|iso|bin|nds|3ds|sfc|smc|nes|gba)$',
               '', s, flags=re.IGNORECASE)

    # Normalize separators and whitespace
    s = s.replace('_', ' ').replace('-', ' ').replace(':', ' ').replace("'", '')
    s = ' '.join(s.split())  # Collapse whitespace

    return s.lower().strip()


def scan_rom_directory_for_compare(rom_dir: Path) -> list:
    """Scan a ROM directory for all ROM files (for comparison)."""
    roms = []

    # Locations to scan
    scan_dirs = [rom_dir]

    # Add hacks subfolder if exists
    hacks_dir = rom_dir / 'hacks'
    if hacks_dir.exists():
        scan_dirs.append(hacks_dir)

    # Add .multidisc subfolder if exists (for PSX)
    multidisc_dir = rom_dir / '.multidisc'
    if multidisc_dir.exists():
        scan_dirs.append(multidisc_dir)

    for scan_dir in scan_dirs:
        try:
            for entry in os.scandir(scan_dir):
                if not entry.is_file():
                    continue

                ext = Path(entry.name).suffix.lower()
                if ext not in ALL_ROM_EXTENSIONS and ext not in ('.m3u',):
                    continue

                # Get base name without extension
                name = Path(entry.name).stem

                # Determine location tag
                if scan_dir == hacks_dir:
                    location = 'hacks/'
                elif scan_dir == multidisc_dir:
                    location = '.multidisc/'
                else:
                    location = ''

                roms.append({
                    'filename': entry.name,
                    'path': entry.path,
                    'name': name,
                    'normalized': normalize_title_for_compare(name),
                    'location': location,
                })
        except PermissionError:
            print(f"  Warning: Cannot access {scan_dir}", file=sys.stderr)

    return roms


def fuzzy_match_rom(needle: str, haystack: list, threshold: int = COMPARE_MATCH_THRESHOLD,
                    alt_needle: str = '') -> Optional[tuple]:
    """Find best fuzzy match for a normalized title in local ROM list."""
    from difflib import SequenceMatcher

    needle_norm = normalize_title_for_compare(needle)
    alt_norm = normalize_title_for_compare(alt_needle) if alt_needle else ''

    best_match = None
    best_score = 0

    for rom in haystack:
        # Calculate similarity against primary needle
        ratio = SequenceMatcher(None, needle_norm, rom['normalized']).ratio()
        score = int(ratio * 100)

        # Also try alt_needle (ROM_Name) if provided - use best score
        if alt_norm:
            alt_ratio = SequenceMatcher(None, alt_norm, rom['normalized']).ratio()
            alt_score = int(alt_ratio * 100)
            score = max(score, alt_score)

        if score > best_score and score >= threshold:
            best_score = score
            best_match = rom

    if best_match:
        return (best_match, best_score)
    return None


def parse_missing_file_for_compare(filepath: Path) -> list:
    """Parse a *-missing.txt TSV file (basic or expanded format)."""
    entries = []
    with open(filepath, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            parts = line.split('\t')
            if len(parts) < 4:
                continue

            title = parts[0]
            achievements = int(parts[1]) if parts[1].isdigit() else 0
            points = int(parts[2]) if parts[2].isdigit() else 0
            url = parts[3]
            hashes = parts[4].split(',') if len(parts) > 4 and parts[4] else []

            # Extended columns (from --rom-info output)
            rom_name = parts[5] if len(parts) > 5 else ''
            file_category = parts[6] if len(parts) > 6 else ''
            labels = parts[7].split(',') if len(parts) > 7 and parts[7] else []
            patch_url = parts[8] if len(parts) > 8 else ''

            # Determine category (priority: file > patch_url > title)
            category = ''
            if file_category:
                category = file_category
            elif patch_url:
                category = get_patch_category(patch_url)

            if not category:
                # Fallback: derive from title prefix
                title_lower = title.lower()
                if '~hack~' in title_lower:
                    category = 'hack'
                elif '~homebrew~' in title_lower:
                    category = 'homebrew'
                elif '~prototype~' in title_lower:
                    category = 'prototype'
                elif '~demo~' in title_lower:
                    category = 'demo'
                elif '~unlicensed~' in title_lower:
                    category = 'unlicensed'
                elif '[subset' in title_lower:
                    category = 'subset'
                else:
                    category = 'base'

            entries.append({
                'title': title,
                'achievements': achievements,
                'points': points,
                'url': url,
                'hashes': hashes,
                'category': category,
                'rom_name': rom_name,
                'labels': labels,
                'patch_url': patch_url,
            })

    return entries


def detect_platform_from_filename(filepath: Path) -> Optional[str]:
    """Detect platform from missing file name (e.g., 'snes' from 'snes-missing.txt')."""
    name = filepath.stem.lower()
    for platform in PLATFORM_TO_FOLDER:
        if name.startswith(platform):
            return platform
    return None


def get_rom_dir_for_platform(platform: str, rom_base: Path = DEFAULT_ROM_BASE) -> Optional[Path]:
    """Get ROM directory for a platform."""
    folder = PLATFORM_TO_FOLDER.get(platform)
    if folder:
        rom_dir = rom_base / folder
        if rom_dir.exists():
            return rom_dir
    return None


def run_compare(missing_file: Path, rom_dir: Path, output_dir: Path,
                threshold: int = COMPARE_MATCH_THRESHOLD) -> dict:
    """Run comparison of missing list against local ROM directory.

    Returns stats dict with results.
    """
    # Use input filename base for output
    output_base = missing_file.stem

    print(f"\nComparing {missing_file.name} against {rom_dir}...", file=sys.stderr)

    # Parse missing entries
    entries = parse_missing_file_for_compare(missing_file)
    print(f"  Entries in missing file: {len(entries)}", file=sys.stderr)

    # Scan ROM directory
    roms = scan_rom_directory_for_compare(rom_dir)
    print(f"  ROMs found in directory: {len(roms)}", file=sys.stderr)

    # Categorize
    truly_missing = []
    possible_matches = []

    for entry in entries:
        match_result = fuzzy_match_rom(entry['title'], roms, threshold,
                                       alt_needle=entry.get('rom_name', ''))

        if match_result:
            rom, score = match_result
            possible_matches.append({
                **entry,
                'match_file': rom['location'] + rom['filename'],
                'match_score': score,
            })
        else:
            truly_missing.append(entry)

    # Write truly missing
    missing_out = output_dir / f"{output_base}-truly-missing.txt"
    with open(missing_out, 'w', encoding='utf-8') as f:
        f.write("# Title\tAchievements\tPoints\tURL\tCategory\n")
        for e in sorted(truly_missing, key=lambda x: (-x['points'], x['title'])):
            f.write(f"{e['title']}\t{e['achievements']}\t{e['points']}\t{e['url']}\t{e['category']}\n")

    # Write possible matches
    matches_out = output_dir / f"{output_base}-possible-matches.txt"
    with open(matches_out, 'w', encoding='utf-8') as f:
        f.write("# RA Title\tMatch Score\tLocal File\tURL\tCategory\n")
        for e in sorted(possible_matches, key=lambda x: (-x['match_score'], x['title'])):
            f.write(f"{e['title']}\t{e['match_score']}%\t{e['match_file']}\t{e['url']}\t{e['category']}\n")

    # Stats
    stats = {
        'total_missing': len(entries),
        'truly_missing': len(truly_missing),
        'possible_matches': len(possible_matches),
        'roms_scanned': len(roms),
        'missing_file': str(missing_out),
        'matches_file': str(matches_out),
    }

    print("\n  Results:", file=sys.stderr)
    print(f"    Truly missing: {len(truly_missing)} (need to acquire)", file=sys.stderr)
    print(f"    Possible matches: {len(possible_matches)} (may need replacement)", file=sys.stderr)
    print(f"    Output: {missing_out.name}, {matches_out.name}", file=sys.stderr)

    return stats


# ============================================================================
# API FUNCTIONS
# ============================================================================


def get_api_key() -> str:
    """Get API key from environment."""
    key = os.environ.get("RA_API_KEY")
    if not key:
        print("Error: RA_API_KEY environment variable not set", file=sys.stderr)
        print("Get your key from: https://retroachievements.org/settings (Keys section)", file=sys.stderr)
        sys.exit(1)
    return key


def api_request(endpoint: str, params: dict) -> dict:
    """Make an API request to RetroAchievements."""
    api_key = get_api_key()
    params["y"] = api_key

    query = "&".join(f"{k}={v}" for k, v in params.items())
    url = f"https://retroachievements.org/API/{endpoint}?{query}"

    try:
        with urllib.request.urlopen(url, timeout=60) as response:
            return json.loads(response.read().decode())
    except urllib.error.HTTPError as e:
        print(f"API Error: {e.code} {e.reason}", file=sys.stderr)
        sys.exit(1)
    except urllib.error.URLError as e:
        print(f"Network Error: {e.reason}", file=sys.stderr)
        sys.exit(1)


def fetch_systems() -> list:
    """Fetch all system IDs from RA."""
    return api_request("API_GetConsoleIDs.php", {})


def fetch_game_list(system_id: int, include_hashes: bool = True) -> list:
    """Fetch all games for a system."""
    params = {"i": system_id}
    if include_hashes:
        params["h"] = 1
        params["f"] = 1  # Include games without achievements
    return api_request("API_GetGameList.php", params)


# ============================================================================
# ROM INFO & PATCH DOWNLOAD
# ============================================================================

def fetch_game_hashes_page(game_id: int) -> dict:
    """Fetch ROM names and patch URLs for a game using the RA API.

    Uses API_GetGameHashes.php which returns:
        {'Results': [{'Name': 'ROM.sfc', 'MD5': 'hash', 'Labels': [...], 'PatchUrl': '...'}, ...]}

    Returns dict with:
        'game_id': int
        'hashes': list of dicts with 'md5', 'name', 'labels', 'patchUrl' (if available)
    """
    api_key = get_api_key()
    url = f"https://retroachievements.org/API/API_GetGameHashes.php?i={game_id}&y={api_key}"

    try:
        with urllib.request.urlopen(url, timeout=60) as response:
            data = json.loads(response.read().decode())
    except urllib.error.HTTPError as e:
        print(f"  Warning: Failed to fetch hashes for game {game_id}: {e.code}", file=sys.stderr)
        return {'game_id': game_id, 'hashes': []}
    except urllib.error.URLError as e:
        print(f"  Warning: Network error fetching game {game_id}: {e.reason}", file=sys.stderr)
        return {'game_id': game_id, 'hashes': []}

    # Convert API response to our format
    results = data.get('Results', [])
    hashes = []
    for r in results:
        hashes.append({
            'md5': r.get('MD5', ''),
            'name': r.get('Name', ''),
            'labels': [{'label': lbl} for lbl in r.get('Labels', [])],
            'patchUrl': r.get('PatchUrl'),  # Can be None
        })

    return {
        'game_id': game_id,
        'hashes': hashes
    }


def is_english_patch(patch_url: str, title: str = '', rom_name: str = '') -> bool:
    """Check if patch should be included (English or non-translation).

    Multi-layer filtering:
    1. RAPatches URL: Check /Translation/ folder structure
    2. Non-RAPatches: Check language markers in filename/URL

    Returns True if patch should be downloaded, False if non-English translation.
    """
    if not patch_url:
        return True  # No URL to check, include by default

    # Layer 1: RAPatches URL check (primary)
    if 'RAPatches' in patch_url or 'retroachievements' in patch_url.lower():
        if '/Translation/' in patch_url:
            # Only include if it's /Translation/English/
            return '/Translation/English/' in patch_url
        # Not a translation folder - include it
        return True

    # Layer 2: Non-RAPatches URL - check for non-English language paths
    non_english_url_paths = [
        '/Japanese/', '/French/', '/German/', '/Spanish/',
        '/Russian/', '/Italian/', '/Korean/', '/Chinese/',
        '/Portuguese/', '/Dutch/', '/Polish/', '/Swedish/',
    ]
    if any(p.lower() in patch_url.lower() for p in non_english_url_paths):
        return False

    # Layer 3: Check filename/title for translation markers with non-English language
    non_english_markers = [
        '(Ja)', '(Fr)', '(De)', '(Es)', '(It)', '(Ko)', '(Zh)', '(Ru)', '(Pt)',
        '(Japan)', '(French)', '(German)', '(Spanish)', '(Italian)',
        '(Korean)', '(Chinese)', '(Russian)', '(Portuguese)',
        '[Ja]', '[Fr]', '[De]', '[Es]', '[It]', '[Ko]', '[Zh]', '[Ru]',
    ]
    translation_markers = ['~Translation~', 'Translation', '-Tr-']

    combined_text = f"{title} {rom_name}".lower()

    # Check if it's marked as a translation AND has non-English marker
    is_translation = any(m.lower() in combined_text for m in translation_markers)
    has_non_english = any(m.lower() in rom_name.lower() for m in non_english_markers)

    if is_translation and has_non_english:
        return False

    return True


def get_patch_category(patch_url: str) -> str:
    """Extract category folder from RAPatches URL structure.

    Example URL: .../RAPatches/raw/main/SNES/Hacks/Super Mario World/...
    Returns: 'hacks' (lowercase)
    """
    if not patch_url or 'RAPatches' not in patch_url:
        return 'other'

    # Pattern: /RAPatches/raw/main/{SYSTEM}/{CATEGORY}/...
    # Categories: Hacks, Translation, Fix, Improvement, Subset, MSU-1, etc.
    match = re.search(r'/RAPatches/raw/main/[^/]+/([^/]+)/', patch_url)
    if match:
        category = match.group(1).lower()
        return category
    return 'other'


def download_patch(patch_url: str, output_dir: Path, system_name: str = '',
                   game_id: int = 0) -> tuple[bool, str]:
    """Download patch from URL to output directory.

    Args:
        patch_url: URL to download from
        output_dir: Base output directory
        system_name: System name for subfolder organization (e.g., 'snes')
        game_id: Game ID for fallback filename

    Returns (success: bool, message: str)
    """
    if not patch_url:
        return False, "No patch URL provided"

    # Extract filename from URL
    filename = patch_url.split('/')[-1]
    if not filename:
        filename = f"patch_{game_id}.zip"

    # Determine output path based on system and category
    if system_name:
        category = get_patch_category(patch_url)
        final_dir = output_dir / system_name / category
    else:
        final_dir = output_dir

    final_dir.mkdir(parents=True, exist_ok=True)
    output_path = final_dir / filename

    # Skip if already downloaded
    if output_path.exists():
        return True, f"Already exists: {filename}"

    try:
        req = urllib.request.Request(patch_url, headers={'User-Agent': 'ra_tool/1.0'})
        with urllib.request.urlopen(req, timeout=120) as response:
            with open(output_path, 'wb') as f:
                f.write(response.read())
        return True, f"Downloaded: {final_dir.name}/{filename}"
    except urllib.error.HTTPError as e:
        return False, f"HTTP Error {e.code}: {filename}"
    except urllib.error.URLError as e:
        return False, f"Network Error: {e.reason}"
    except Exception as e:
        return False, f"Error: {str(e)}"


def get_rom_info_for_missing(missing_games: list, rate_limit: float = 0.5,
                             verbose: bool = False) -> dict:
    """Query RA hash pages for missing games to get ROM names and patch URLs.

    Args:
        missing_games: List of dicts with 'title', 'url', 'hashes', etc.
        rate_limit: Delay between requests in seconds
        verbose: Show progress

    Returns dict with:
        'base_games': list of base game info
        'hacks_with_patches': list of hacks that have patches
        'hacks_without_patches': list of hacks without patches
        'translations_skipped': list of non-English translations skipped
        'errors': list of games that failed to fetch
    """
    result = {
        'base_games': [],
        'hacks_with_patches': [],
        'hacks_without_patches': [],
        'translations_skipped': [],
        'errors': [],
    }

    total = len(missing_games)

    for idx, game in enumerate(missing_games, 1):
        title = game.get('title', '')
        url = game.get('url', '')

        # Extract game ID from URL
        # URL format: https://retroachievements.org/game/270
        match = re.search(r'/game/(\d+)', url)
        if not match:
            result['errors'].append({**game, 'error': 'Could not extract game ID from URL'})
            continue

        game_id = int(match.group(1))

        if verbose:
            print(f"  [{idx}/{total}] Fetching ROM info for: {title[:50]}...", file=sys.stderr)

        # Fetch hash page
        hash_data = fetch_game_hashes_page(game_id)

        # Rate limit
        if idx < total:
            time.sleep(rate_limit)

        hashes = hash_data.get('hashes', [])

        # Determine category
        title_lower = title.lower()
        is_hack = '~hack~' in title_lower
        is_translation = '~translation~' in title_lower
        is_homebrew = '~homebrew~' in title_lower
        # Note: prototype, demo, unlicensed, subset are categorized as base games

        # Find patches and collect all hash info
        patches = []
        rom_names = []
        all_hash_info = []  # Store full info for each hash
        all_labels = set()  # Unique labels across all hashes
        for h in hashes:
            rom_name = h.get('name', '')
            patch_url = h.get('patchUrl', '')
            labels = [lbl.get('label', '') for lbl in h.get('labels', [])]
            md5 = h.get('md5', '')

            rom_names.append(rom_name)
            all_labels.update(labels)
            all_hash_info.append({
                'rom_name': rom_name,
                'md5': md5,
                'labels': labels,
                'patch_url': patch_url,
            })

            if patch_url:
                # Check if English
                if is_english_patch(patch_url, title, rom_name):
                    patches.append({
                        'rom_name': rom_name,
                        'patch_url': patch_url,
                        'md5': md5,
                        'labels': labels,
                    })
                else:
                    # Non-English translation - track it
                    if is_translation:
                        result['translations_skipped'].append({
                            **game,
                            'rom_name': rom_name,
                            'patch_url': patch_url,
                            'reason': 'Non-English translation',
                        })

        # Build info entry
        info = {
            **game,
            'game_id': game_id,
            'rom_names': rom_names,
            'patches': patches,
            'all_hash_info': all_hash_info,
            'labels': list(all_labels),
        }

        # Categorize
        if is_translation and not patches:
            # Translation with no English patches - already tracked above or no patches at all
            if not any(h.get('patchUrl') for h in hashes):
                result['translations_skipped'].append({
                    **info,
                    'reason': 'Translation with no patches',
                })
        elif is_hack or is_homebrew:
            if patches:
                result['hacks_with_patches'].append(info)
            else:
                result['hacks_without_patches'].append(info)
        else:
            # Base game, prototype, demo, unlicensed, subset
            result['base_games'].append(info)

    return result


def format_rom_info_report(rom_info: dict, local_hashes: set = None) -> str:
    """Format ROM info into a readable report.

    Args:
        rom_info: Result from get_rom_info_for_missing()
        local_hashes: Set of hashes from local ROM collection (for base ROM check)
    """
    lines = []
    lines.append("=" * 70)
    lines.append("MISSING GAMES - ROM INFO")
    lines.append("=" * 70)

    # Base games
    if rom_info['base_games']:
        lines.append("")
        lines.append("[BASE GAMES]")
        lines.append("-" * 40)
        for g in sorted(rom_info['base_games'], key=lambda x: x['title']):
            lines.append(f"\n{g['title']}")
            if g['rom_names']:
                lines.append(f"  ROM: {g['rom_names'][0]}")
            if g.get('hashes'):
                lines.append(f"  Hash: {g['hashes'][0] if g['hashes'] else 'N/A'}")
            lines.append(f"  URL: {g['url']}")
            if g['patches']:
                lines.append(f"  Patch: {g['patches'][0]['patch_url']}")

    # Hacks with patches
    if rom_info['hacks_with_patches']:
        lines.append("")
        lines.append("[HACKS/HOMEBREW WITH PATCHES]")
        lines.append("-" * 40)
        for g in sorted(rom_info['hacks_with_patches'], key=lambda x: x['title']):
            lines.append(f"\n{g['title']}")
            if g['rom_names']:
                lines.append(f"  ROM: {g['rom_names'][0]}")
            if g['patches']:
                patch = g['patches'][0]
                lines.append(f"  Patch: {patch['patch_url']}")
                # Try to identify base ROM from patch filename
                patch_name = patch['rom_name']
                # Often base ROM is mentioned before hack name
                base_match = re.match(r'^([^-]+(?:\([^)]+\))?)', patch_name)
                if base_match:
                    base_hint = base_match.group(1).strip()
                    if base_hint and base_hint != patch_name:
                        lines.append(f"  Base ROM hint: {base_hint}")
            lines.append(f"  URL: {g['url']}")

    # Hacks without patches
    if rom_info['hacks_without_patches']:
        lines.append("")
        lines.append("[HACKS/HOMEBREW WITHOUT PATCHES]")
        lines.append("-" * 40)
        for g in sorted(rom_info['hacks_without_patches'], key=lambda x: x['title']):
            lines.append(f"\n{g['title']}")
            # Show ROM names if available
            if g.get('rom_names') and g['rom_names'][0]:
                lines.append(f"  ROM: {g['rom_names'][0]}")
                if len(g['rom_names']) > 1:
                    lines.append(f"       (+ {len(g['rom_names']) - 1} other version(s))")
            else:
                lines.append("  ROM: (unknown)")
            # Show labels - especially important for lostlevel
            labels = g.get('labels', [])
            if labels:
                label_str = ', '.join(labels)
                lines.append(f"  Source: {label_str}")
                if 'lostlevel' in labels:
                    lines.append("  Note: 'lostlevel' = rare/hard to find, may need specialized sources")
            else:
                lines.append("  Source: manual (no RAPatches available)")
            lines.append(f"  URL: {g['url']}")

    # Skipped translations
    if rom_info['translations_skipped']:
        lines.append("")
        lines.append("[TRANSLATIONS - SKIPPED]")
        lines.append("-" * 40)
        for g in sorted(rom_info['translations_skipped'], key=lambda x: x['title']):
            lines.append(f"\n{g['title']}")
            lines.append(f"  Skipped: {g.get('reason', 'Non-English translation')}")

    # Summary
    lines.append("")
    lines.append("=" * 70)
    lines.append("SUMMARY")
    lines.append("=" * 70)
    total = (len(rom_info['base_games']) + len(rom_info['hacks_with_patches']) +
             len(rom_info['hacks_without_patches']) + len(rom_info['translations_skipped']))
    lines.append(f"Total missing: {total}")
    lines.append(f"  Base games: {len(rom_info['base_games'])}")
    lines.append(f"  Hacks/homebrew with patches: {len(rom_info['hacks_with_patches'])}")
    lines.append(f"  Hacks/homebrew without patches: {len(rom_info['hacks_without_patches'])}")
    lines.append(f"  Translations skipped: {len(rom_info['translations_skipped'])}")
    if rom_info['errors']:
        lines.append(f"  Errors: {len(rom_info['errors'])}")

    return '\n'.join(lines)


def write_missing_list_basic(output_path: str, sorted_missing: list):
    """Write basic missing list TSV (no ROM info)."""
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write("# Title\tAchievements\tPoints\tURL\tHashes\n")
        for gid, info in sorted_missing:
            hashes = ','.join(info.get('hashes', [])[:5])
            f.write(f"{info['title']}\t{info['achievements']}\t{info['points']}\t"
                    f"https://retroachievements.org/game/{gid}\t{hashes}\n")


def write_missing_list_expanded(output_path: str, sorted_missing: list, rom_info: dict):
    """Write expanded missing list TSV with ROM info columns."""
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write("# Title\tAchievements\tPoints\tURL\tHashes\t"
                "ROM_Name\tCategory\tLabels\tPatch_URL\n")

        # Build lookup from rom_info by title for easy access
        rom_lookup = {}
        for g in rom_info.get('base_games', []):
            rom_lookup[g['title']] = ('base', g)
        for g in rom_info.get('hacks_with_patches', []):
            rom_lookup[g['title']] = ('hack_patched', g)
        for g in rom_info.get('hacks_without_patches', []):
            rom_lookup[g['title']] = ('hack_no_patch', g)
        for g in rom_info.get('translations_skipped', []):
            rom_lookup[g['title']] = ('translation_skipped', g)

        for gid, info in sorted_missing:
            title = info['title']
            hashes = ','.join(info.get('hashes', [])[:5])
            url = f"https://retroachievements.org/game/{gid}"

            # Get ROM info if available
            if title in rom_lookup:
                category, g = rom_lookup[title]
                rom_name = g.get('rom_names', [''])[0] if g.get('rom_names') else ''
                labels = ','.join(g.get('labels', []))
                patch_url = ''
                if g.get('patches'):
                    patch_url = g['patches'][0].get('patch_url', '')
            else:
                rom_name = ''
                category = ''
                labels = ''
                patch_url = ''

            f.write(f"{title}\t{info['achievements']}\t{info['points']}\t{url}\t"
                    f"{hashes}\t{rom_name}\t{category}\t{labels}\t{patch_url}\n")


# ============================================================================
# RAHASHER DETECTION
# ============================================================================


def find_rahasher() -> Optional[str]:
    """Find RAHasher executable."""
    # Check environment variable first
    env_path = os.environ.get('RA_HASHER')
    if env_path and os.path.isfile(env_path):
        return env_path

    # Check PATH
    rahasher = shutil.which('RAHasher') or shutil.which('rahasher')
    if rahasher:
        return rahasher

    # Check common locations directly (in preference order)
    # ~/bin is checked first as user's preferred location
    common_paths = [
        Path.home() / 'bin' / 'RAHasher',
        Path.home() / '.local' / 'bin' / 'RAHasher',
        Path('/usr/local/bin/RAHasher'),
        Path('/opt/retroachievements/RAHasher'),
    ]
    for p in common_paths:
        if p.exists() and p.is_file():
            return str(p)

    return None


def get_rahasher_install_dir() -> Path:
    """Get the preferred directory for installing RAHasher."""
    # Prefer ~/bin if it exists (user's custom bin)
    home_bin = Path.home() / 'bin'
    if home_bin.exists() and home_bin.is_dir():
        return home_bin

    # Fall back to ~/.local/bin (XDG standard)
    local_bin = Path.home() / '.local' / 'bin'
    # Create it if needed - this is the guaranteed fallback
    local_bin.mkdir(parents=True, exist_ok=True)
    return local_bin


def verify_rahasher(rahasher_path: str) -> bool:
    """Verify RAHasher works."""
    try:
        subprocess.run(
            [rahasher_path],
            capture_output=True,
            text=True,
            timeout=5
        )
        # RAHasher with no args returns usage info
        return True
    except (FileNotFoundError, subprocess.TimeoutExpired, PermissionError):
        return False


def get_rahasher_version(rahasher_path: str) -> Optional[str]:
    """Get the installed RAHasher version."""
    try:
        result = subprocess.run(
            [rahasher_path],
            capture_output=True,
            text=True,
            timeout=5
        )
        # RAHasher outputs version in format: "RAHasher - X.Y.Z\n..."
        output = result.stdout + result.stderr  # Version might be in either
        for line in output.split('\n'):
            if 'RAHasher' in line:
                # Extract version number (e.g., "RAHasher - 1.8.1" or "RAHasher 1.8.1")
                import re
                match = re.search(r'(\d+\.\d+(?:\.\d+)?)', line)
                if match:
                    return match.group(1)
        return None
    except (FileNotFoundError, subprocess.TimeoutExpired, PermissionError):
        return None


def get_latest_rahasher_version() -> Optional[tuple]:
    """Get the latest RAHasher version from GitHub.

    Returns tuple of (version_string, release_url) or None on failure.
    """
    try:
        url = "https://api.github.com/repos/RetroAchievements/RALibretro/releases/latest"
        req = urllib.request.Request(url, headers={'User-Agent': 'ra_tool'})
        with urllib.request.urlopen(req, timeout=15) as response:
            data = json.loads(response.read().decode())
            tag = data.get('tag_name', '')
            html_url = data.get('html_url', '')
            # Tag might be "1.8.1" or "v1.8.1"
            version = tag.lstrip('v')
            return (version, html_url)
    except Exception:
        return None


def parse_version(version_str: str) -> tuple:
    """Parse version string into tuple for comparison."""
    try:
        parts = version_str.split('.')
        return tuple(int(p) for p in parts)
    except (ValueError, AttributeError):
        return (0,)


def check_rahasher_version(rahasher_path: str, verbose: bool = True) -> dict:
    """Check if RAHasher is up to date.

    Returns dict with keys: installed, latest, up_to_date, release_url
    """
    result = {
        'installed': None,
        'latest': None,
        'up_to_date': None,
        'release_url': None
    }

    installed = get_rahasher_version(rahasher_path)
    result['installed'] = installed

    latest_info = get_latest_rahasher_version()
    if latest_info:
        result['latest'] = latest_info[0]
        result['release_url'] = latest_info[1]

    if installed and result['latest']:
        installed_tuple = parse_version(installed)
        latest_tuple = parse_version(result['latest'])
        result['up_to_date'] = installed_tuple >= latest_tuple

        if verbose:
            if result['up_to_date']:
                print(f"RAHasher {installed} is up to date")
            else:
                print(f"RAHasher {installed} is outdated (latest: {result['latest']})")
                print(f"  Update: {result['release_url']}")
                print("  Or run: ra_tool.py setup --upgrade")
    elif verbose and installed:
        print(f"RAHasher {installed} installed (could not check for updates)")

    return result


def check_dependencies(system_id: Optional[int] = None) -> dict:
    """
    Check availability of required dependencies for archive extraction and conversion.

    Args:
        system_id: Optional system ID to check system-specific deps (e.g., dolphin-tool for GC/Wii)

    Returns:
        dict with dependency availability info
    """
    deps = {
        'zipfile': True,       # builtin
        'py7zr': PY7ZR_AVAILABLE,
        '7z': shutil.which('7z'),
        'dolphin_tool': None,  # path or None
    }

    # Check dolphin-tool (only needed for GC/Wii RVZ files)
    if system_id in (16, 19) or system_id is None:
        deps['dolphin_tool'] = shutil.which('dolphin-tool') or shutil.which('DolphinTool')

    return deps


def convert_rvz_to_iso(rvz_path: Path, temp_dir: Path) -> Optional[Path]:
    """
    Convert RVZ to ISO using dolphin-tool.
    Returns path to temporary ISO file, or None if conversion fails.

    Args:
        rvz_path: Path to the RVZ file
        temp_dir: Temporary directory for the converted ISO

    Returns:
        Path to the converted ISO, or None if conversion failed
    """
    iso_path = temp_dir / (rvz_path.stem + '.iso')

    # Find dolphin-tool
    dolphin_tool = shutil.which('dolphin-tool') or shutil.which('DolphinTool')
    if not dolphin_tool:
        print("  dolphin-tool not found, cannot convert RVZ", file=sys.stderr)
        return None

    try:
        result = subprocess.run(
            [dolphin_tool, 'convert', '-i', str(rvz_path), '-o', str(iso_path), '-f', 'iso'],
            capture_output=True,
            text=True,
            timeout=600  # 10 min timeout for large files
        )
        if result.returncode == 0 and iso_path.exists():
            return iso_path
        if result.stderr:
            print(f"  dolphin-tool error: {result.stderr.strip()}", file=sys.stderr)
    except subprocess.TimeoutExpired:
        print(f"  dolphin-tool timeout for: {rvz_path.name}", file=sys.stderr)
    except FileNotFoundError:
        print("  dolphin-tool not found", file=sys.stderr)
    except Exception as e:
        print(f"  dolphin-tool error: {e}", file=sys.stderr)

    return None


# ============================================================================
# HASHING FUNCTIONS
# ============================================================================


def hash_with_rahasher(filepath: Path, system_id: int, rahasher_path: str, verbose: bool = False) -> Optional[str]:
    """Hash a file using RAHasher. Handles all formats including CHD."""
    try:
        result = subprocess.run(
            [rahasher_path, str(system_id), str(filepath)],
            capture_output=True,
            text=True,
            timeout=300  # 5 min timeout for large CHD files
        )
        # RAHasher outputs: "hash" or "hash\nFAIL" (FAIL means not in its internal DB)
        # We want the hash regardless of exit code or FAIL status
        # Check both stdout and stderr - RAHasher may output to either depending on version/conditions
        output = result.stdout.strip()
        if not output:
            output = result.stderr.strip()
        if output:
            # Get the first line (the hash), ignore FAIL/OK lines
            first_line = output.split('\n')[0].strip()
            # Get the hash (first word if multiple, or the whole thing)
            hash_val = first_line.split()[0] if ' ' in first_line else first_line
            # Validate it looks like a hash (32 hex chars for MD5)
            if len(hash_val) == 32 and all(c in '0123456789abcdef' for c in hash_val.lower()):
                return hash_val.lower()
            # Could be longer hash, just return it if it looks hex
            if hash_val and all(c in '0123456789abcdef' for c in hash_val.lower()):
                return hash_val.lower()
        # Log error for debugging (only in verbose mode)
        if verbose:
            if result.stderr:
                print(f"  RAHasher stderr: {result.stderr.strip()}", file=sys.stderr)
            if result.returncode != 0 and not output:
                print(f"  RAHasher exit code: {result.returncode}", file=sys.stderr)
        return None
    except FileNotFoundError:
        return None
    except subprocess.TimeoutExpired:
        print(f"  RAHasher timeout for: {filepath.name}", file=sys.stderr)
        return None
    except Exception as e:
        print(f"  RAHasher error: {e}", file=sys.stderr)
        return None


def md5_file(filepath: Path) -> str:
    """Calculate MD5 hash of a file (fallback when RAHasher unavailable)."""
    hash_md5 = hashlib.md5()
    with open(filepath, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()


def hash_rom(filepath: Path, system_id: int, rahasher_path: Optional[str] = None, verbose: bool = False) -> list:
    """
    Hash a ROM file for RetroAchievements comparison.
    Returns list of (hash_type, hash_value) tuples.

    Strategy:
    - For most cartridge systems: RA uses plain MD5 of ROM data (no RAHasher needed)
    - For systems in RAHASHER_REQUIRED: RAHasher computes special hashes
      (header stripping for NES/Lynx, sector hashing for disc systems)
    """
    suffix = filepath.suffix.lower()

    # Check if this system requires RAHasher (disc-based or has headers to strip)
    needs_rahasher = system_id in RAHASHER_REQUIRED

    # Build combined sets for extension detection
    all_disc_extensions = set(
        DISC_EXTENSIONS +
        NINTENDO_DISC_EXTENSIONS +
        SEGA_DISC_EXTENSIONS +
        SONY_DISC_EXTENSIONS +
        MICROSOFT_EXTENSIONS
    )
    all_cart_extensions = set(CARTRIDGE_EXTENSIONS)
    all_rom_extensions = all_cart_extensions | all_disc_extensions

    # --- Handle ZIP files ---
    if suffix == ".zip":
        try:
            with zipfile.ZipFile(filepath, 'r') as zf:
                # Find the ROM file inside the ZIP
                rom_file = None
                for name in zf.namelist():
                    name_lower = name.lower()
                    # Skip directories and common non-ROM files
                    if name.endswith('/') or name_lower.endswith((
                            '.txt', '.nfo', '.diz', '.doc', '.rtf',
                            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.pdf',
                            '.htm', '.html', '.xml', '.url',
                            '.ips', '.bps', '.ups', '.xdelta', '.ppf', '.aps',
                            '.asm', '.src', '.bat', '.sh', '.exe')):
                        continue
                    # Check if file matches known ROM extensions
                    for ext in all_rom_extensions:
                        if name_lower.endswith(ext):
                            rom_file = name
                            break
                    if rom_file:
                        break

                if not rom_file:
                    return [('error', 'no_rom_in_zip')]

                # For systems requiring RAHasher: extract to temp, run RAHasher
                if needs_rahasher:
                    if not rahasher_path:
                        return [('error', 'rahasher_required')]
                    with tempfile.TemporaryDirectory() as tmpdir:
                        extracted = Path(tmpdir) / Path(rom_file).name
                        extracted.write_bytes(zf.read(rom_file))
                        ra_hash = hash_with_rahasher(extracted, system_id, rahasher_path, verbose)
                        if ra_hash:
                            return [('rahasher', ra_hash)]
                        return [('error', 'rahasher_failed')]

                # For cartridge systems: MD5 the ROM data directly (no extraction needed)
                data = zf.read(rom_file)
                return [('md5', hashlib.md5(data).hexdigest())]

        except zipfile.BadZipFile:
            return [('error', 'bad_zip')]

    # --- Handle 7z files ---
    elif suffix == ".7z":
        # Try py7zr first (pure Python, faster for small archives)
        if PY7ZR_AVAILABLE:
            try:
                with py7zr.SevenZipFile(filepath, mode='r') as szf:
                    # Find the ROM file inside the 7z
                    rom_file = None
                    for name in szf.getnames():
                        name_lower = name.lower()
                        # Skip directories and common non-ROM files
                        if name.endswith('/') or name_lower.endswith((
                                '.txt', '.nfo', '.diz', '.doc', '.rtf',
                                '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.pdf',
                                '.htm', '.html', '.xml', '.url',
                                '.ips', '.bps', '.ups', '.xdelta', '.ppf', '.aps',
                                '.asm', '.src', '.bat', '.sh', '.exe')):
                            continue
                        # Check if file matches known ROM extensions
                        for ext in all_rom_extensions:
                            if name_lower.endswith(ext):
                                rom_file = name
                                break
                        if rom_file:
                            break

                    if not rom_file:
                        return [('error', 'no_rom_in_7z')]

                    # For systems requiring RAHasher: extract to temp, run RAHasher
                    if needs_rahasher:
                        if not rahasher_path:
                            return [('error', 'rahasher_required')]
                        with tempfile.TemporaryDirectory() as tmpdir:
                            szf.extract(path=tmpdir, targets=[rom_file])
                            extracted = Path(tmpdir) / rom_file
                            ra_hash = hash_with_rahasher(extracted, system_id, rahasher_path, verbose)
                            if ra_hash:
                                return [('rahasher', ra_hash)]
                            return [('error', 'rahasher_failed')]

                    # For cartridge systems: extract and MD5 the ROM data
                    with tempfile.TemporaryDirectory() as tmpdir:
                        szf.extract(path=tmpdir, targets=[rom_file])
                        extracted = Path(tmpdir) / rom_file
                        data = extracted.read_bytes()
                        return [('md5', hashlib.md5(data).hexdigest())]

            except py7zr.Bad7zFile:
                return [('error', 'bad_7z')]
            except Exception as e:
                return [('error', f'7z_error:{str(e)}')]

        # Fallback to 7z CLI
        elif shutil.which('7z'):
            try:
                with tempfile.TemporaryDirectory() as tmpdir:
                    # Extract all files to temp dir
                    result = subprocess.run(
                        ['7z', 'x', str(filepath), f'-o{tmpdir}', '-y'],
                        capture_output=True,
                        text=True,
                        timeout=300
                    )
                    if result.returncode != 0:
                        return [('error', 'bad_7z')]

                    # Find the ROM file in extracted contents
                    rom_file = None
                    for root, dirs, files in os.walk(tmpdir):
                        for name in files:
                            name_lower = name.lower()
                            # Skip common non-ROM files
                            if name_lower.endswith((
                                    '.txt', '.nfo', '.diz', '.doc', '.rtf',
                                    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.pdf',
                                    '.htm', '.html', '.xml', '.url',
                                    '.ips', '.bps', '.ups', '.xdelta', '.ppf', '.aps',
                                    '.asm', '.src', '.bat', '.sh', '.exe')):
                                continue
                            # Check if file matches known ROM extensions
                            for ext in all_rom_extensions:
                                if name_lower.endswith(ext):
                                    rom_file = Path(root) / name
                                    break
                            if rom_file:
                                break
                        if rom_file:
                            break

                    if not rom_file:
                        return [('error', 'no_rom_in_7z')]

                    # For systems requiring RAHasher
                    if needs_rahasher:
                        if not rahasher_path:
                            return [('error', 'rahasher_required')]
                        ra_hash = hash_with_rahasher(rom_file, system_id, rahasher_path, verbose)
                        if ra_hash:
                            return [('rahasher', ra_hash)]
                        return [('error', 'rahasher_failed')]

                    # For cartridge systems: MD5 the ROM data
                    data = rom_file.read_bytes()
                    return [('md5', hashlib.md5(data).hexdigest())]

            except subprocess.TimeoutExpired:
                return [('error', '7z_timeout')]
            except Exception as e:
                return [('error', f'7z_error:{str(e)}')]

        else:
            return [('error', '7z_not_available')]

    # --- Handle RAR files (not supported) ---
    elif suffix == ".rar":
        return [('error', 'rar_not_supported')]

    # --- Handle unsupported compressed disc formats ---
    elif suffix in UNSUPPORTED_DISC_FORMATS:
        return [('error', f'unsupported_format:{suffix}')]

    # --- Handle regular (non-archive) files ---
    else:
        # Pre-process RVZ files for GameCube/Wii (RAHasher may not support RVZ directly)
        if suffix == '.rvz' and system_id in (16, 19):
            with tempfile.TemporaryDirectory() as tmpdir:
                converted_iso = convert_rvz_to_iso(filepath, Path(tmpdir))
                if converted_iso:
                    # Hash the converted ISO
                    if not rahasher_path:
                        return [('error', 'rahasher_required')]
                    ra_hash = hash_with_rahasher(converted_iso, system_id, rahasher_path, verbose)
                    if ra_hash:
                        return [('rahasher', ra_hash)]
                    return [('error', 'rahasher_failed')]
                else:
                    return [('error', 'rvz_conversion_failed')]

        # Systems requiring RAHasher (disc/header systems)
        if needs_rahasher:
            if not rahasher_path:
                return [('error', 'rahasher_required')]
            ra_hash = hash_with_rahasher(filepath, system_id, rahasher_path, verbose)
            if ra_hash:
                return [('rahasher', ra_hash)]
            return [('error', 'rahasher_failed')]

        # Cartridge systems: plain MD5
        return [('md5', md5_file(filepath))]

# ============================================================================
# CACHE MANAGEMENT
# ============================================================================


def get_cache_path(system_id: int) -> Path:
    """Get cache file path for a system."""
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    return CACHE_DIR / f"ra_system_{system_id}.json"


def is_cache_valid(system_id: int) -> bool:
    """Check if cache exists and is not expired (< 6 months old)."""
    cache_path = get_cache_path(system_id)
    if not cache_path.exists():
        return False

    # Check file modification time
    mtime = datetime.fromtimestamp(cache_path.stat().st_mtime)
    expiry = datetime.now() - timedelta(days=CACHE_EXPIRY_DAYS)

    if mtime < expiry:
        return False

    # Also check internal timestamp if present
    try:
        with open(cache_path) as f:
            data = json.load(f)
        cached_time = data.get('cached_at')
        if cached_time:
            cached_dt = datetime.fromisoformat(cached_time)
            if cached_dt < expiry:
                return False
    except (json.JSONDecodeError, KeyError, ValueError):
        return False

    return True


def get_cache_age_str(system_id: int) -> str:
    """Get human-readable cache age."""
    cache_path = get_cache_path(system_id)
    if not cache_path.exists():
        return "not cached"

    mtime = datetime.fromtimestamp(cache_path.stat().st_mtime)
    age = datetime.now() - mtime

    if age.days > 0:
        return f"{age.days} days old"
    elif age.seconds > 3600:
        return f"{age.seconds // 3600} hours old"
    else:
        return "recent"


def load_cached_hashes(system_id: int) -> Optional[dict]:
    """Load cached hash database for a system."""
    cache_path = get_cache_path(system_id)
    if cache_path.exists():
        try:
            with open(cache_path) as f:
                return json.load(f)
        except json.JSONDecodeError:
            return None
    return None


def save_cached_hashes(system_id: int, data: dict):
    """Save hash database to cache."""
    cache_path = get_cache_path(system_id)
    with open(cache_path, "w") as f:
        json.dump(data, f)
    print(f"  Cached to: {cache_path}", file=sys.stderr)


def build_hash_lookup(games: list) -> dict:
    """Build hash -> game info lookup from game list."""
    lookup = {}
    for game in games:
        game_hashes = game.get('Hashes', [])
        info = {
            'title': game.get('Title', 'Unknown'),
            'id': game.get('ID', 0),
            'achievements': game.get('NumAchievements', 0),
            'points': game.get('Points', 0),
            'linked_hashes': len(game_hashes),
        }
        for h in game_hashes:
            lookup[h.lower()] = info
    return lookup


def print_summary_line(total_roms: int, supported: int, unsupported: int,
                       achievements: int, points: int, duplicates: int = 0,
                       total_achievable: int = 0):
    """Print a compact summary line to stderr."""
    dup_str = f", {duplicates} dupes" if duplicates > 0 else ""
    print(f"\n Scanned {total_roms} ROMs  {supported} supported, "
          f"{unsupported} unsupported{dup_str}", file=sys.stderr)
    print(f"  Achievable: {achievements} achievements ({points} pts)", file=sys.stderr)
    if total_achievable > 0:
        pct = 100 * supported / total_achievable
        print(f"  Collection: {supported}/{total_achievable} RA titles ({pct:.1f}%)", file=sys.stderr)


def make_progress_bar(iterable, total=None, desc="Processing", disable=False):
    """
    Create a progress bar that handles terminal resizing gracefully.
    Falls back to simple iteration if tqdm is not available.
    """
    if not TQDM_AVAILABLE or disable:
        return iterable

    return tqdm(
        iterable,
        total=total,
        desc=desc,
        unit="ROM",
        ncols=None,  # Auto-detect terminal width
        dynamic_ncols=True,  # Handle terminal resize
        leave=False,  # Clean up after completion
        file=sys.stderr,
        bar_format="{desc}: {percentage:3.0f}%|{bar}| {n_fmt}/{total_fmt} {postfix}"
    )


def copy_roms_to_dest(rom_dir: Path, roms_to_copy: list, dest: Path,
                      copy_mode: str = 'copy', skip_no_achievements: bool = True):
    """
    Copy/move/symlink ROMs to categorized destination folders.

    Args:
        rom_dir: Base directory where source ROMs are located
        roms_to_copy: List of dicts with 'path', 'title', 'achievements' keys
        dest: Destination base path (subfolders will be created)
        copy_mode: 'copy', 'move', or 'symlink'
        skip_no_achievements: If True, skip ROMs with 0 achievements

    Returns:
        dict of category -> count copied
    """
    # Create category subfolders
    category_dirs = {
        'base': dest / 'base',
        'hack': dest / 'hack',
        'homebrew': dest / 'homebrew',
        'special': dest / 'special',
        'subset': dest / 'base',  # subsets go with base games
    }
    for d in set(category_dirs.values()):
        d.mkdir(parents=True, exist_ok=True)

    copied = {'base': 0, 'hack': 0, 'homebrew': 0, 'special': 0}

    for entry in roms_to_copy:
        # Skip games without achievements if requested
        if skip_no_achievements and entry.get('achievements', 0) == 0:
            continue

        title = entry['title']
        category, _ = categorize_title(title)

        src_path = rom_dir / entry['path']
        dest_dir = category_dirs.get(category, category_dirs['base'])
        dest_path = dest_dir / src_path.name

        if dest_path.exists():
            print(f"  [SKIP] Already exists: {dest_path.name}", file=sys.stderr)
            continue

        try:
            if copy_mode == 'copy':
                shutil.copy2(src_path, dest_path)
            elif copy_mode == 'move':
                shutil.move(src_path, dest_path)
            elif copy_mode == 'symlink':
                dest_path.symlink_to(src_path.resolve())

            copied[category] = copied.get(category, 0) + 1
        except (IOError, OSError) as e:
            print(f"  [ERROR] Failed to {copy_mode} {src_path.name}: {e}", file=sys.stderr)

    # Summary
    total_copied = sum(copied.values())
    action_word = 'Copied' if copy_mode == 'copy' else 'Moved' if copy_mode == 'move' else 'Linked'
    print(f"\n {action_word} {total_copied} ROMs to {dest}:", file=sys.stderr)
    for cat, count in sorted(copied.items()):
        if count > 0:
            print(f"  {cat}/: {count}", file=sys.stderr)

    return copied


def ensure_cache(system_id: int, force: bool = False) -> dict:
    """
    Ensure cache is available and valid. Auto-pulls if needed.
    Returns the cached data.
    """
    if not force and is_cache_valid(system_id):
        cached = load_cached_hashes(system_id)
        if cached:
            age = get_cache_age_str(system_id)
            print(f"  Using cached data ({age})", file=sys.stderr)
            return cached

    # Need to pull
    reason = "expired" if get_cache_path(system_id).exists() else "missing"
    print(f"  Cache {reason}, pulling from RA API...", file=sys.stderr)

    games = fetch_game_list(system_id)
    if not games:
        print(f"  Warning: No games returned for system {system_id}", file=sys.stderr)
        return {'system_id': system_id, 'games': [], 'lookup': {}, 'game_count': 0, 'hash_count': 0}

    lookup = build_hash_lookup(games)

    data = {
        'system_id': system_id,
        'cached_at': datetime.now().isoformat(),
        'game_count': len(games),
        'hash_count': len(lookup),
        'games': games,
        'lookup': lookup,
    }

    save_cached_hashes(system_id, data)
    print(f"  Cached {len(games)} games, {len(lookup)} hashes", file=sys.stderr)
    return data

# ============================================================================
# COMMANDS
# ============================================================================


def cmd_systems(args):
    """List all RA systems."""
    systems = fetch_systems()

    print(f"{'ID':<4} {'Name':<40} {'Active':<8} {'Game System'}")
    print("-" * 70)

    for console in sorted(systems, key=lambda x: x.get('ID', 0)):
        sys_id = console.get('ID', 0)
        name = console.get('Name', 'Unknown')
        active = "Yes" if console.get('Active') else "No"
        is_game = "Yes" if console.get('IsGameSystem') else "No"

        # Mark systems requiring RAHasher
        marker = "*" if sys_id in RAHASHER_REQUIRED else " "
        print(f"{sys_id:<4}{marker}{name:<40} {active:<8} {is_game}")

    print()
    print("* = Requires RAHasher for accurate hashing (disc-based or special header)")


def cmd_pull(args):
    """Pull hash database for system(s)."""
    if args.system.lower() == "all":
        cached_systems = ensure_systems_cache()
        system_ids = [s['ID'] for s in cached_systems['systems'] if s.get('IsGameSystem')]
        print(f"Pulling {len(system_ids)} systems...", file=sys.stderr)
    else:
        system_ids = [resolve_system_id(args.system)]

    for sys_id in system_ids:
        print(f"\nFetching system {sys_id}...", file=sys.stderr)
        games = fetch_game_list(sys_id)

        if not games:
            print(f"  No games found for system {sys_id}", file=sys.stderr)
            continue

        # Build lookup and save
        lookup = build_hash_lookup(games)

        data = {
            'system_id': sys_id,
            'cached_at': datetime.now().isoformat(),
            'game_count': len(games),
            'hash_count': len(lookup),
            'games': games,
            'lookup': lookup,
        }

        save_cached_hashes(sys_id, data)
        print(f"   {len(games)} games, {len(lookup)} hashes", file=sys.stderr)


def cmd_check(args):
    """Check ROMs against cached database (auto-pulls if needed)."""
    system_id = resolve_system_id(args.system)
    rom_dir = Path(args.rom_dir)

    if not rom_dir.exists():
        print(f"Error: Directory not found: {rom_dir}", file=sys.stderr)
        sys.exit(1)

    # Find RAHasher
    rahasher = find_rahasher()
    if rahasher:
        if not verify_rahasher(rahasher):
            print(f"Warning: RAHasher found but not working: {rahasher}", file=sys.stderr)
            rahasher = None
        else:
            version = get_rahasher_version(rahasher)
            version_str = f" ({version})" if version else ""
            print(f"Using RAHasher: {rahasher}{version_str}", file=sys.stderr)
            # Quick version check (non-blocking)
            check_rahasher_version(rahasher, verbose=False)
    else:
        print("Warning: RAHasher not found. Disc-based formats (CHD, CUE, ISO) will fail.", file=sys.stderr)
        print("Run 'ra_tool.py setup' to install RAHasher.", file=sys.stderr)

    # Auto-pull if cache missing or expired (or forced)
    print(f"Loading hash database for system {system_id}...", file=sys.stderr)
    cached = ensure_cache(system_id, force=getattr(args, 'force', False))
    lookup = cached.get('lookup', {})

    if not lookup:
        print(f"Error: No hashes available for system {system_id}", file=sys.stderr)
        sys.exit(1)

    # Find ROM files
    rom_files = []
    for ext in ALL_ROM_EXTENSIONS:
        rom_files.extend(rom_dir.rglob(f"*{ext}"))
        # Also check uppercase
        rom_files.extend(rom_dir.rglob(f"*{ext.upper()}"))

    # Deduplicate (rglob can return same file for different case patterns)
    rom_files = list(set(rom_files))

    print(f"Found {len(rom_files)} ROM files to check", file=sys.stderr)

    if not rom_files:
        print("No ROM files found in directory.", file=sys.stderr)
        return

    # Check each ROM
    supported = []
    supported_no_ach = []
    unsupported = []
    errors = []
    stats = {'ok': 0, 'no_ach': 0, 'unsup': 0, 'ach': 0}

    pbar = make_progress_bar(rom_files, total=len(rom_files), desc="Hashing")
    for rom_path in pbar:
        rel_path = rom_path.relative_to(rom_dir)
        hashes = hash_rom(rom_path, system_id, rahasher, args.verbose)

        if not hashes:
            errors.append((str(rel_path), 'no_hash'))
            continue

        if hashes[0][0] == 'error':
            errors.append((str(rel_path), hashes[0][1]))
            continue

        # Check against lookup
        matched = None
        matched_hash = None
        for hash_type, hash_val in hashes:
            if hash_val.lower() in lookup:
                matched = lookup[hash_val.lower()]
                matched_hash = hash_val
                break

        if matched:
            if matched['achievements'] > 0:
                supported.append((str(rel_path), matched, matched_hash))
                stats['ok'] += 1
                stats['ach'] += matched['achievements']
            else:
                supported_no_ach.append((str(rel_path), matched, matched_hash))
                stats['no_ach'] += 1
        else:
            unsupported.append((str(rel_path), [h[1] for h in hashes if h[0] != 'error']))
            stats['unsup'] += 1

        # Update progress bar with live stats
        if TQDM_AVAILABLE and hasattr(pbar, 'set_postfix_str'):
            pbar.set_postfix_str(f"{stats['ok']} {stats['no_ach']} {stats['unsup']} {stats['ach']}")

    # Setup output (file or stdout)
    output_file = None
    output = sys.stdout
    summary_only = getattr(args, 'summary', False)

    if args.output:
        output_file = open(args.output, 'w')
        output = output_file
        print(f"Writing report to: {args.output}", file=sys.stderr)

    def out(msg=""):
        print(msg, file=output)

    # Summary header (always shown)
    out("\n" + "=" * 70)
    out("RETROACHIEVEMENTS COMPATIBILITY REPORT")
    out("=" * 70)
    out(f"System ID: {system_id}")
    out(f"ROM Directory: {rom_dir}")
    out(f"Database: {cached.get('game_count', '?')} games, {cached.get('hash_count', '?')} hashes")
    cache_age = get_cache_age_str(system_id)
    out(f"Cache: {cache_age}")
    out("\nResults:")
    out(f"   Supported (achievements): {len(supported)}")
    out(f"   Supported (no achievements): {len(supported_no_ach)}")
    out(f"   Not found: {len(unsupported)}")
    if errors:
        out(f"  ! Errors: {len(errors)}")

    # Detailed sections (skip if summary_only)
    if not summary_only:
        # Supported with achievements
        if supported:
            out("\n" + "=" * 70)
            out(f"SUPPORTED - ACHIEVEMENTS AVAILABLE ({len(supported)})")
            out("=" * 70)
            for rom, info, h in sorted(supported, key=lambda x: -x[1]['achievements']):
                out(f"\n{rom}")
                out(f"   {info['title']}")
                linked = info.get('linked_hashes', 1)
                linked_str = f" (1 of {linked} linked hashes)" if linked > 1 else ""
                out(f"    {info['achievements']} achievements, {info['points']} points{linked_str}")
                out(f"    https://retroachievements.org/game/{info['id']}")

        # Supported without achievements
        if supported_no_ach and args.verbose:
            out("\n" + "=" * 70)
            out(f"SUPPORTED - NO ACHIEVEMENTS ({len(supported_no_ach)})")
            out("=" * 70)
            for rom, info, h in sorted(supported_no_ach, key=lambda x: x[1]['title']):
                out(f"\n{rom}")
                out(f"   {info['title']}")
                linked = info.get('linked_hashes', 1)
                if linked > 1:
                    out(f"    (1 of {linked} linked hashes)")

        # Unsupported
        if unsupported:
            out("\n" + "=" * 70)
            out(f"NOT IN DATABASE ({len(unsupported)})")
            out("=" * 70)
            for rom, hashes in sorted(unsupported):
                out(f"\n{rom}")
                if hashes:
                    out(f"  MD5: {hashes[0]}")

        # Errors
        if errors:
            out("\n" + "=" * 70)
            out(f"ERRORS ({len(errors)})")
            out("=" * 70)
            for rom, err in sorted(errors):
                out(f"\n{rom}")
                out(f"  Error: {err}")

    # Close file if opened
    if output_file:
        output_file.close()
        print(f"Report saved to: {args.output}", file=sys.stderr)

    # Print summary to stderr
    total_ach = sum(info['achievements'] for _, info, _ in supported)
    total_pts = sum(info['points'] for _, info, _ in supported)
    print_summary_line(
        total_roms=len(rom_files),
        supported=len(supported) + len(supported_no_ach),
        unsupported=len(unsupported),
        achievements=total_ach,
        points=total_pts,
        total_achievable=cached.get('game_count', 0)
    )

    # Copy matched ROMs if --copy-to specified (copies ALL matches)
    copy_dest = getattr(args, 'copy_to', None)
    if copy_dest:
        copy_dest = Path(copy_dest)
        copy_mode = getattr(args, 'copy_mode', 'copy')

        # Build list of all matched ROMs (both with and without achievements)
        roms_to_copy = []
        for rom, info, h in supported:
            roms_to_copy.append({
                'path': rom,
                'title': info['title'],
                'achievements': info['achievements'],
            })
        for rom, info, h in supported_no_ach:
            roms_to_copy.append({
                'path': rom,
                'title': info['title'],
                'achievements': info['achievements'],
            })

        copy_roms_to_dest(rom_dir, roms_to_copy, copy_dest, copy_mode,
                          skip_no_achievements=True)

    # Show missing RA titles (games with achievements you don't have)
    show_missing = getattr(args, 'missing', False)
    missing_base_only = getattr(args, 'missing_base_only', False)
    missing_list_file = getattr(args, 'missing_list', None)
    rom_info_flag = getattr(args, 'rom_info', False)
    download_patches_flag = getattr(args, 'download_patches', False)
    compare_flag = getattr(args, 'compare', None)

    # --compare implies --missing-list (need the file to compare against)
    if compare_flag and not missing_list_file:
        missing_list_file = True  # Will be resolved to default filename below

    # Resolve default filename for --missing-list if flag used without value
    if missing_list_file is True:
        system_name = get_system_name(system_id)
        suffix = '-base-missing.txt' if missing_base_only else '-missing.txt'
        missing_list_file = f"{system_name}{suffix}"

    needs_missing_info = (show_missing or missing_list_file or missing_base_only or
                          rom_info_flag or download_patches_flag)
    if needs_missing_info:
        games = cached.get('games', [])

        # Build game_id -> game_info lookup (include hashes for missing report)
        game_info = {}
        for g in games:
            game_info[g.get('ID')] = {
                'title': g.get('Title', 'Unknown'),
                'achievements': g.get('NumAchievements', 0),
                'points': g.get('Points', 0),
                'hashes': g.get('Hashes', []),
            }

        # Get game IDs that were found in the check
        found_game_ids = set()
        for _, info, _ in supported:
            found_game_ids.add(info['id'])
        for _, info, _ in supported_no_ach:
            found_game_ids.add(info['id'])

        # Find all games with achievements that user doesn't have
        all_achievable = {
            gid: info for gid, info in game_info.items()
            if info['achievements'] > 0
        }

        missing_games = {}
        for gid, info in all_achievable.items():
            if gid in found_game_ids:
                continue

            title = info['title']
            title_lower = title.lower()

            # Apply base-only filter: exclude hacks, demos, subsets
            # Include: base, homebrew, prototype, unlicensed (standalone titles)
            if missing_base_only:
                if '[subset' in title_lower:
                    continue
                if '~hack~' in title_lower:
                    continue
                if '~demo~' in title_lower:
                    continue

            missing_games[gid] = info

        # Calculate totals
        missing_ach = sum(g['achievements'] for g in missing_games.values())
        missing_pts = sum(g['points'] for g in missing_games.values())

        # Sort by achievements descending
        sorted_missing = sorted(
            missing_games.items(),
            key=lambda x: (-x[1]['achievements'], x[1]['title'])
        )

        # Show to stderr if --missing flag
        if show_missing or missing_base_only:
            filter_label = " (base games only)" if missing_base_only else ""
            print(f"\n{'=' * 70}", file=sys.stderr)
            print(f"MISSING RA TITLES{filter_label} ({len(missing_games)} games, "
                  f"{missing_ach} achievements, {missing_pts} points)", file=sys.stderr)
            print("=" * 70, file=sys.stderr)

            # Show top 25 by achievements
            for gid, info in sorted_missing[:25]:
                print(f"  {info['title']}", file=sys.stderr)
                print(f"    {info['achievements']} achievements, {info['points']} points", file=sys.stderr)
                print(f"    https://retroachievements.org/game/{gid}", file=sys.stderr)

            if len(sorted_missing) > 25:
                print(f"\n  ... and {len(sorted_missing) - 25} more (use --missing-list to export all)",
                      file=sys.stderr)

        # ROM info and patch download for missing games
        patch_dir = getattr(args, 'patch_dir', Path('./patches'))

        if rom_info_flag or download_patches_flag:
            # Convert missing_games to list format for get_rom_info_for_missing()
            missing_list = []
            for gid, info in sorted_missing:
                missing_list.append({
                    'title': info['title'],
                    'achievements': info['achievements'],
                    'points': info['points'],
                    'url': f"https://retroachievements.org/game/{gid}",
                    'hashes': info.get('hashes', []),
                })

            print(f"\nQuerying ROM info for {len(missing_list)} missing games...", file=sys.stderr)
            rom_info = get_rom_info_for_missing(missing_list, rate_limit=0.5, verbose=True)

            # Print report
            if rom_info_flag:
                local_hashes = {h for _, hs in unsupported for h in hs}
                report = format_rom_info_report(rom_info, local_hashes)
                print(report)

            # Download patches
            if download_patches_flag:
                all_patches = []
                for g in rom_info['base_games']:
                    all_patches.extend(g.get('patches', []))
                for g in rom_info['hacks_with_patches']:
                    all_patches.extend(g.get('patches', []))

                if all_patches:
                    sys_name = get_system_name(system_id)
                    print(f"\nDownloading {len(all_patches)} patches to "
                          f"{patch_dir}/{sys_name}/...", file=sys.stderr)
                    success_count = 0
                    fail_count = 0
                    for patch in all_patches:
                        ok, msg = download_patch(patch['patch_url'], patch_dir, sys_name)
                        if ok:
                            success_count += 1
                        else:
                            fail_count += 1
                            print(f"  Failed: {msg}", file=sys.stderr)
                        time.sleep(0.3)  # Rate limit downloads
                    print(f"Patches: {success_count} downloaded, {fail_count} failed", file=sys.stderr)
                else:
                    print("No patches available to download.", file=sys.stderr)

            # Write missing list with expanded columns (ROM info was fetched)
            if missing_list_file:
                write_missing_list_expanded(
                    missing_list_file, sorted_missing, rom_info)
                print(f"MISSING list saved to: {missing_list_file}", file=sys.stderr)

        elif missing_list_file:
            # Write basic missing list (no ROM info)
            write_missing_list_basic(missing_list_file, sorted_missing)
            print(f"MISSING list saved to: {missing_list_file}", file=sys.stderr)

        # Run comparison if --compare flag was used
        if compare_flag and missing_list_file:
            # Determine compare directory
            if compare_flag is True:
                compare_dir = rom_dir  # Default to same ROM dir
            else:
                compare_dir = Path(compare_flag)

            if compare_dir.exists():
                run_compare(Path(missing_list_file), compare_dir, Path('.'))
            else:
                print(f"Warning: Compare directory not found: {compare_dir}", file=sys.stderr)


def cmd_hash(args):
    """Hash a single file using RAHasher."""
    system_id = resolve_system_id(args.system)
    filepath = Path(args.file)

    if not filepath.exists():
        print(f"Error: File not found: {filepath}", file=sys.stderr)
        sys.exit(1)

    # Find RAHasher
    rahasher = find_rahasher()
    if rahasher:
        if not verify_rahasher(rahasher):
            print(f"Warning: RAHasher found but not working: {rahasher}", file=sys.stderr)
            rahasher = None
        else:
            version = get_rahasher_version(rahasher)
            version_str = f" ({version})" if version else ""
            print(f"Using RAHasher: {rahasher}{version_str}", file=sys.stderr)
    else:
        print("Warning: RAHasher not found, using fallback MD5", file=sys.stderr)

    hashes = hash_rom(filepath, system_id, rahasher, verbose=True)

    print(f"\nFile: {filepath}")
    print(f"Size: {filepath.stat().st_size:,} bytes")
    print(f"System ID: {system_id}")
    print("\nHashes:")
    for hash_type, hash_val in hashes:
        status = "" if hash_type == 'rahasher' else ""
        print(f"  {status} {hash_type}: {hash_val}")

    # If we have a cached DB, check if this hash matches anything
    cached = load_cached_hashes(system_id)
    if cached and 'lookup' in cached:
        lookup = cached['lookup']
        for hash_type, hash_val in hashes:
            if hash_val.lower() in lookup:
                info = lookup[hash_val.lower()]
                print("\n MATCH FOUND:")
                print(f"  Title: {info['title']}")
                print(f"  Achievements: {info['achievements']}")
                print(f"  Points: {info['points']}")
                print(f"  https://retroachievements.org/game/{info['id']}")
                return
        print(f"\n No match in cached database ({cached.get('hash_count', 0)} hashes)")
    else:
        print(f"\n  (No cached DB for system {system_id} - run 'check' to auto-pull)")


def cmd_compare(args):
    """Compare missing list against local ROM collection."""
    all_mode = getattr(args, 'all', False)
    threshold = getattr(args, 'threshold', COMPARE_MATCH_THRESHOLD)
    output_dir = getattr(args, 'output_dir', Path('.'))
    rom_base = getattr(args, 'rom_base', DEFAULT_ROM_BASE)

    # Collect files to process
    missing_files = []

    if all_mode:
        # Find all *-missing.txt files in current directory (exclude output files)
        for f in Path('.').glob('*-missing*.txt'):
            name = f.stem.lower()
            if 'truly-missing' in name or 'possible-matches' in name:
                continue
            missing_files.append(f)
        if not missing_files:
            print("No *-missing.txt files found in current directory.", file=sys.stderr)
            sys.exit(1)
    else:
        missing_file = getattr(args, 'missing_file', None)
        if not missing_file:
            print("Error: Provide a missing file or use --all", file=sys.stderr)
            sys.exit(1)
        missing_files.append(Path(missing_file))

    # Process each file
    all_stats = []

    for missing_file in sorted(missing_files):
        if not missing_file.exists():
            print(f"Warning: {missing_file} not found, skipping", file=sys.stderr)
            continue

        # Determine ROM directory
        rom_dir_arg = getattr(args, 'rom_dir', None)
        if rom_dir_arg:
            rom_dir = Path(rom_dir_arg)
        else:
            # Auto-detect from filename
            platform = detect_platform_from_filename(missing_file)
            if platform:
                rom_dir = get_rom_dir_for_platform(platform, rom_base)
                if not rom_dir:
                    print(f"Warning: ROM dir not found for {platform}, skipping", file=sys.stderr)
                    continue
            else:
                print(f"Warning: Cannot detect platform from {missing_file}, skipping", file=sys.stderr)
                continue

        if not rom_dir.exists():
            print(f"Warning: ROM directory not found: {rom_dir}, skipping", file=sys.stderr)
            continue

        stats = run_compare(missing_file, rom_dir, output_dir, threshold)
        stats['platform'] = detect_platform_from_filename(missing_file) or 'unknown'
        all_stats.append(stats)

    # Summary
    if len(all_stats) > 1:
        print("\n" + "=" * 60, file=sys.stderr)
        print("SUMMARY", file=sys.stderr)
        print("=" * 60, file=sys.stderr)

        total_missing = sum(s['truly_missing'] for s in all_stats)
        total_matches = sum(s['possible_matches'] for s in all_stats)

        for s in all_stats:
            print(f"  {s['platform'].upper()}: {s['truly_missing']} missing, "
                  f"{s['possible_matches']} possible matches", file=sys.stderr)

        print(f"\n  TOTAL: {total_missing} truly missing, "
              f"{total_matches} possible matches", file=sys.stderr)


# ============================================================================
# MAIN
# ============================================================================


def cmd_setup(args):
    """Download and install RAHasher."""
    import platform
    import stat

    upgrade = getattr(args, 'upgrade', False)
    check_only = getattr(args, 'check', False)

    # Check if RAHasher is already installed
    existing = find_rahasher()
    if existing:
        print(f"Found existing RAHasher: {existing}")
        version_info = check_rahasher_version(existing, verbose=True)

        if check_only:
            # Just checking version, done
            sys.exit(0 if version_info.get('up_to_date', True) else 1)

        if version_info.get('up_to_date') and not upgrade:
            print("\nRAHasher is already up to date. Use --upgrade to reinstall.")
            sys.exit(0)

        if not upgrade and version_info.get('installed'):
            print("\nUse --upgrade to update to the latest version.")
            sys.exit(0)

        print("\nProceeding with upgrade...")

    # Detect platform
    system = platform.system().lower()
    machine = platform.machine().lower()

    # Asset naming: RAHasher-{arch}-{os}-{version}.zip
    # Arch: x64 (64-bit), x86 (32-bit), aarch64 (ARM64)
    if system == 'linux':
        if machine in ('x86_64', 'amd64'):
            asset_pattern = 'RAHasher-x64-Linux'
        elif machine in ('aarch64', 'arm64'):
            asset_pattern = 'RAHasher-aarch64-Linux'
        elif machine in ('i386', 'i686', 'x86'):
            asset_pattern = 'RAHasher-x86-Linux'
        else:
            print(f"Unsupported architecture: {machine}", file=sys.stderr)
            sys.exit(1)
    elif system == 'darwin':
        # macOS - try x64 first, may not have ARM builds yet
        if machine in ('arm64', 'aarch64'):
            asset_pattern = 'RAHasher-aarch64-Darwin'
        else:
            asset_pattern = 'RAHasher-x64-Darwin'
    elif system == 'windows':
        if machine in ('amd64', 'x86_64'):
            asset_pattern = 'RAHasher-x64-Windows'
        else:
            asset_pattern = 'RAHasher-x86-Windows'
    else:
        print(f"Unsupported OS: {system}", file=sys.stderr)
        sys.exit(1)

    print(f"Platform: {system} {machine}")
    print(f"Looking for: {asset_pattern}")

    # Get latest release info from GitHub API
    print("Fetching latest RAHasher release...")
    try:
        url = "https://api.github.com/repos/RetroAchievements/RALibretro/releases/latest"
        req = urllib.request.Request(url, headers={'User-Agent': 'ra_tool'})
        with urllib.request.urlopen(req, timeout=30) as response:
            release = json.loads(response.read().decode())
    except Exception as e:
        print(f"Error fetching release info: {e}", file=sys.stderr)
        sys.exit(1)

    # Find matching asset
    download_url = None
    asset_name = None
    for asset in release.get('assets', []):
        name = asset.get('name', '')
        if asset_pattern in name and name.endswith('.zip'):
            download_url = asset.get('browser_download_url')
            asset_name = name
            break

    if not download_url:
        print(f"Could not find RAHasher for {asset_pattern}", file=sys.stderr)
        print("Available assets:", file=sys.stderr)
        for asset in release.get('assets', []):
            print(f"  {asset.get('name')}", file=sys.stderr)
        sys.exit(1)

    print(f"Found: {asset_name}")
    print(f"Downloading from: {download_url}")

    # Download to temp location
    import tempfile
    with tempfile.TemporaryDirectory() as tmpdir:
        zip_path = Path(tmpdir) / asset_name
        try:
            req = urllib.request.Request(download_url, headers={'User-Agent': 'ra_tool'})
            with urllib.request.urlopen(req, timeout=120) as response:
                with open(zip_path, 'wb') as f:
                    f.write(response.read())
        except Exception as e:
            print(f"Error downloading: {e}", file=sys.stderr)
            sys.exit(1)

        print(f"Downloaded: {zip_path.stat().st_size:,} bytes")

        # Extract
        with zipfile.ZipFile(zip_path, 'r') as zf:
            zf.extractall(tmpdir)

        # Find RAHasher binary
        rahasher_bin = None
        for f in Path(tmpdir).rglob('RAHasher*'):
            if f.is_file() and 'zip' not in f.suffix.lower():
                rahasher_bin = f
                break

        if not rahasher_bin:
            print("Could not find RAHasher binary in archive", file=sys.stderr)
            sys.exit(1)

        # Install location - prefers ~/bin if exists, falls back to ~/.local/bin
        install_dir = get_rahasher_install_dir()
        install_path = install_dir / rahasher_bin.name

        # Copy binary
        shutil.copy2(rahasher_bin, install_path)

        # Make executable (Linux/Mac)
        if system != 'windows':
            install_path.chmod(install_path.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP)

        print(f"\n Installed to: {install_path}")

        # Check if in PATH
        if str(install_dir) not in os.environ.get('PATH', ''):
            print(f"\nNote: {install_dir} may not be in your PATH.")
            print("Add to your shell config:")
            print(f'  export PATH="$PATH:{install_dir}"')
        else:
            print("RAHasher is ready to use!")

        # Verify and show version
        if verify_rahasher(str(install_path)):
            version = get_rahasher_version(str(install_path))
            if version:
                print(f"\n RAHasher {version} installed and verified")
            else:
                print("\n RAHasher verified working")
        else:
            print("\n! RAHasher installed but verification failed", file=sys.stderr)

    # Show optional dependencies status
    print("\n" + "=" * 50)
    print("Optional Dependencies:")
    print("=" * 50)
    deps = check_dependencies()

    # 7z archive support
    if deps['py7zr']:
        print("  7z archives:     py7zr (Python module)")
    elif deps['7z']:
        print(f"  7z archives:     7z CLI ({deps['7z']})")
    else:
        print("  7z archives:     Not available")
        print("                  Install: pip install py7zr  OR  pacman -S p7zip")

    # RVZ conversion (for GC/Wii)
    if deps['dolphin_tool']:
        print(f"  RVZ conversion:  dolphin-tool ({deps['dolphin_tool']})")
    else:
        print("  RVZ conversion:  Not available (needed for GC/Wii RVZ files)")
        print("                  Install: pacman -S dolphin-emu  (includes dolphin-tool)")


def cmd_dedup(args):
    """RA-aware deduplication - find best ROM per game for achievements."""
    from collections import defaultdict
    import csv

    system_id = resolve_system_id(args.system)
    rom_dir = Path(args.rom_dir)
    output_format = getattr(args, 'format', 'text')

    if not rom_dir.exists():
        print(f"Error: Directory not found: {rom_dir}", file=sys.stderr)
        sys.exit(1)

    # Find RAHasher
    rahasher = find_rahasher()
    if rahasher:
        if not verify_rahasher(rahasher):
            print(f"Warning: RAHasher found but not working: {rahasher}",
                  file=sys.stderr)
            rahasher = None
        else:
            version = get_rahasher_version(rahasher)
            version_str = f" ({version})" if version else ""
            print(f"Using RAHasher: {rahasher}{version_str}", file=sys.stderr)
            # Quick version check (non-blocking)
            check_rahasher_version(rahasher, verbose=False)
    else:
        print("Warning: RAHasher not found. Run 'ra_tool.py setup' to install.",
              file=sys.stderr)

    # Auto-pull if cache missing or expired
    print(f"Loading hash database for system {system_id}...", file=sys.stderr)
    cached = ensure_cache(system_id, force=getattr(args, 'force', False))
    lookup = cached.get('lookup', {})
    games = cached.get('games', [])

    if not lookup:
        print(f"Error: No hashes available for system {system_id}",
              file=sys.stderr)
        sys.exit(1)

    # Build game_id -> game_info lookup (include hashes for missing report)
    game_info = {}
    for g in games:
        game_info[g.get('ID')] = {
            'title': g.get('Title', 'Unknown'),
            'achievements': g.get('NumAchievements', 0),
            'points': g.get('Points', 0),
            'hashes': g.get('Hashes', []),
        }

    # Find ROM files
    rom_files = []
    for ext in ALL_ROM_EXTENSIONS:
        rom_files.extend(rom_dir.rglob(f"*{ext}"))
        rom_files.extend(rom_dir.rglob(f"*{ext.upper()}"))
    rom_files = list(set(rom_files))

    print(f"Found {len(rom_files)} ROM files to analyze", file=sys.stderr)

    # Hash each ROM and group by RA game ID
    games_found = defaultdict(list)
    unsupported = []
    stats = {'ok': 0, 'no_ach': 0, 'unsup': 0, 'ach': 0}
    seen_games = set()

    pbar = make_progress_bar(rom_files, total=len(rom_files), desc="Hashing")
    for rom_path in pbar:
        rel_path = rom_path.relative_to(rom_dir)
        hashes = hash_rom(rom_path, system_id, rahasher, args.verbose)

        if not hashes or hashes[0][0] == 'error':
            continue

        # Check against lookup
        matched_game_id = None
        matched_hash = None
        matched_info = None
        for hash_type, hash_val in hashes:
            if hash_val.lower() in lookup:
                matched_info = lookup[hash_val.lower()]
                matched_game_id = matched_info['id']
                matched_hash = hash_val
                break

        if matched_game_id:
            # Track unique games for stats
            if matched_game_id not in seen_games:
                seen_games.add(matched_game_id)
                ach_count = matched_info.get('achievements', 0)
                if ach_count > 0:
                    stats['ok'] += 1
                    stats['ach'] += ach_count
                else:
                    stats['no_ach'] += 1

            # Score region preference (higher = better)
            name = rom_path.stem.lower()
            region_score = 0
            if '(usa)' in name or '(us)' in name or '(u)' in name:
                region_score = 100
            elif '(world)' in name:
                region_score = 90
            elif '(europe)' in name or '(eu)' in name or '(e)' in name:
                region_score = 80
            elif '(japan)' in name or '(jp)' in name or '(j)' in name:
                region_score = 70
            else:
                region_score = 50

            # Boost for Rev 1, Rev 2 etc (newer is usually better)
            if 'rev 2' in name or '(rev 2)' in name:
                region_score += 3
            elif 'rev 1' in name or '(rev 1)' in name:
                region_score += 2
            elif 'rev' in name:
                region_score += 1

            games_found[matched_game_id].append({
                'path': str(rel_path),
                'hash': matched_hash,
                'score': region_score,
            })
        else:
            unsupported.append({'path': str(rel_path), 'hash': hashes[0][1] if hashes else ''})
            stats['unsup'] += 1

        # Update progress bar with live stats
        if TQDM_AVAILABLE and hasattr(pbar, 'set_postfix_str'):
            pbar.set_postfix_str(f"{stats['ok']} {stats['no_ach']} {stats['unsup']} {stats['ach']}")

    # Build result data structure
    keep_list = []
    delete_list = []
    results = []

    for game_id, roms in games_found.items():
        info = game_info.get(game_id, {})
        sorted_roms = sorted(roms, key=lambda x: -x['score'])

        for j, rom in enumerate(sorted_roms):
            action = 'keep' if j == 0 else 'delete'
            entry = {
                'action': action,
                'path': rom['path'],
                'game_id': game_id,
                'title': info.get('title', 'Unknown'),
                'achievements': info.get('achievements', 0),
                'points': info.get('points', 0),
                'hash': rom['hash'],
                'score': rom['score'],
                'url': f"https://retroachievements.org/game/{game_id}",
            }
            results.append(entry)
            if action == 'keep':
                keep_list.append(rom['path'])
            else:
                delete_list.append(rom['path'])

    # Calculate totals
    total_ach = sum(game_info.get(gid, {}).get('achievements', 0) for gid in games_found.keys())
    total_pts = sum(game_info.get(gid, {}).get('points', 0) for gid in games_found.keys())

    summary = {
        'system_id': system_id,
        'directory': str(rom_dir),
        'total_roms': len(rom_files),
        'unique_games': len(games_found),
        'keep_count': len(keep_list),
        'delete_count': len(delete_list),
        'unsupported_count': len(unsupported),
        'total_achievements': total_ach,
        'total_points': total_pts,
    }

    # Determine output destination
    summary_only = getattr(args, 'summary', False)
    output_file = getattr(args, 'output', None)

    # Skip full output if --summary flag is set
    if not summary_only:
        out_handle = open(output_file, 'w') if output_file else sys.stdout

        try:
            # Output based on format
            if output_format == 'json':
                output_data = {
                    'summary': summary,
                    'results': results,
                    'unsupported': unsupported,
                }
                print(json.dumps(output_data, indent=2), file=out_handle)

            elif output_format == 'csv':
                # CSV output - one row per ROM, easy to filter/sort
                writer = csv.DictWriter(out_handle, fieldnames=[
                    'action', 'path', 'game_id', 'title', 'achievements', 'points', 'hash', 'score'
                ])
                writer.writeheader()
                for r in results:
                    writer.writerow({k: r[k] for k in writer.fieldnames})
                # Add unsupported with action='unsupported'
                for u in unsupported:
                    writer.writerow({
                        'action': 'unsupported', 'path': u['path'], 'game_id': '',
                        'title': '', 'achievements': '', 'points': '', 'hash': u['hash'], 'score': ''
                    })

            else:  # text format (default)
                # Games with duplicates
                duplicates = {gid: roms for gid, roms in games_found.items() if len(roms) > 1}

                if duplicates:
                    print(f"DUPLICATES ({len(duplicates)} games with multiple ROMs)", file=out_handle)
                    print("=" * 50, file=out_handle)

                    for game_id, roms in sorted(duplicates.items(),
                                                key=lambda x: game_info.get(x[0], {}).get('title', '')):
                        info = game_info.get(game_id, {})
                        title = info.get('title', f'Game {game_id}')
                        achievements = info.get('achievements', 0)
                        points = info.get('points', 0)

                        print(f"\n{title}", file=out_handle)
                        print(f"  ({achievements} achievements, {points} points)", file=out_handle)
                        print(f"  https://retroachievements.org/game/{game_id}", file=out_handle)

                        sorted_roms = sorted(roms, key=lambda x: -x['score'])
                        for j, rom in enumerate(sorted_roms):
                            if j == 0:
                                print(f"   KEEP: {rom['path']}", file=out_handle)
                            else:
                                print(f"   DUP:  {rom['path']}", file=out_handle)
                else:
                    print("No duplicates found.", file=out_handle)

        finally:
            if output_file:
                out_handle.close()

        if output_file:
            print(f"  Output saved to: {output_file}", file=sys.stderr)

    # Always print summary to stderr (visible even when output goes to file)
    duplicates = {gid: roms for gid, roms in games_found.items() if len(roms) > 1}
    all_achievable = {gid: info for gid, info in game_info.items()
                      if info.get('achievements', 0) > 0}
    print_summary_line(
        total_roms=len(rom_files),
        supported=len(games_found),
        unsupported=len(unsupported),
        achievements=total_ach,
        points=total_pts,
        duplicates=len(duplicates),
        total_achievable=len(all_achievable)
    )

    # Output files if requested (works with any format)
    if args.keep_list:
        with open(args.keep_list, 'w') as f:
            for p in sorted(keep_list):
                f.write(p + '\n')
        print(f"\nKEEP list saved to: {args.keep_list}", file=sys.stderr)

    if args.delete_list:
        with open(args.delete_list, 'w') as f:
            for p in sorted(delete_list):
                f.write(p + '\n')
        print(f"DELETE list saved to: {args.delete_list}", file=sys.stderr)

    if args.unsupported_list:
        with open(args.unsupported_list, 'w') as f:
            for u in sorted(unsupported, key=lambda x: x['path']):
                f.write(u['path'] + '\n')
        print(f"UNSUPPORTED list saved to: {args.unsupported_list}", file=sys.stderr)

    # Copy matched ROMs if --copy-to specified (only 'keep' entries, skips duplicates)
    copy_dest = getattr(args, 'copy_to', None)
    if copy_dest:
        copy_dest = Path(copy_dest)
        copy_mode = getattr(args, 'copy_mode', 'copy')

        # Only copy 'keep' entries (one per game, best region preference)
        roms_to_copy = [
            {'path': e['path'], 'title': e['title'], 'achievements': e['achievements']}
            for e in results if e['action'] == 'keep'
        ]
        copy_roms_to_dest(rom_dir, roms_to_copy, copy_dest, copy_mode,
                          skip_no_achievements=True)

    # Show missing RA titles (games with achievements you don't have)
    show_missing = getattr(args, 'missing', False)
    missing_base_only = getattr(args, 'missing_base_only', False)
    missing_list_file = getattr(args, 'missing_list', None)
    summary_only = getattr(args, 'summary', False)
    rom_info_flag = getattr(args, 'rom_info', False)
    download_patches_flag = getattr(args, 'download_patches', False)
    compare_flag = getattr(args, 'compare', None)

    # --compare implies --missing-list (need the file to compare against)
    if compare_flag and not missing_list_file:
        missing_list_file = True  # Will be resolved to default filename below

    # Resolve default filename for --missing-list if flag used without value
    if missing_list_file is True:
        system_name = get_system_name(system_id)
        suffix = '-base-missing.txt' if missing_base_only else '-missing.txt'
        missing_list_file = f"{system_name}{suffix}"

    needs_missing_info = (show_missing or missing_list_file or missing_base_only or
                          rom_info_flag or download_patches_flag)
    if needs_missing_info:
        # Find all games with achievements that user doesn't have
        all_achievable = {
            gid: info for gid, info in game_info.items()
            if info.get('achievements', 0) > 0
        }

        # Build set of base game titles user owns
        owned_base_titles = set()
        for gid in games_found.keys():
            info = game_info.get(gid, {})
            cat, base = categorize_title(info.get('title', ''))
            if cat == 'base':
                owned_base_titles.add(info.get('title', ''))
            elif cat == 'subset':
                owned_base_titles.add(base)

        # Find missing games
        missing_games = {}
        subsets_owned_base = []  # Subsets for games you already own

        for gid, info in all_achievable.items():
            if gid in games_found:
                continue  # Already have this exact game

            title = info.get('title', '')
            cat, base = categorize_title(title)

            # Skip subsets if you own the base game (you can already earn those achievements)
            if cat == 'subset' and base in owned_base_titles:
                subsets_owned_base.append((gid, info))
                continue

            # Apply base-only filter: exclude hacks, demos, subsets
            # Include: base, homebrew, prototype, unlicensed (standalone titles)
            if missing_base_only:
                title_lower = title.lower()
                if cat == 'subset':
                    continue
                if cat == 'hack':
                    continue
                if '~demo~' in title_lower:
                    continue

            missing_games[gid] = info

        # Calculate stats
        missing_ach = sum(info['achievements'] for info in missing_games.values())
        missing_pts = sum(info['points'] for info in missing_games.values())
        subset_ach = sum(info['achievements'] for _, info in subsets_owned_base)
        subset_pts = sum(info['points'] for _, info in subsets_owned_base)

        # Sort by points descending (most valuable first)
        sorted_missing = sorted(
            missing_games.items(),
            key=lambda x: (-x[1]['points'], -x[1]['achievements'])
        )

        # Show to stderr if --missing flag
        if show_missing or missing_base_only:
            filter_label = " (base games only)" if missing_base_only else ""
            print(f"\n{'=' * 70}", file=sys.stderr)
            print(f"MISSING RA TITLES{filter_label} ({len(missing_games)} games, "
                  f"{missing_ach} achievements, {missing_pts} points)", file=sys.stderr)
            print(f"{'=' * 70}", file=sys.stderr)

            # Show all if not summary mode, otherwise top 50
            show_count = len(sorted_missing) if not summary_only else min(50, len(sorted_missing))

            for gid, info in sorted_missing[:show_count]:
                title = info['title']
                hashes = info.get('hashes', [])
                hash_str = hashes[0] if hashes else 'no hash'

                print(f"  {title}", file=sys.stderr)
                print(f"    {info['achievements']} ach, {info['points']} pts | "
                      f"{hash_str} | https://retroachievements.org/game/{gid}", file=sys.stderr)

            if len(sorted_missing) > show_count:
                remaining = len(sorted_missing) - show_count
                print(f"\n  ... and {remaining} more (use without -s to see all)", file=sys.stderr)

            # Stats
            base_achievable = sum(
                1 for gid, info in all_achievable.items()
                if categorize_title(info['title'])[0] == 'base'
            )
            base_owned = sum(
                1 for gid in games_found
                if categorize_title(game_info.get(gid, {}).get('title', ''))[0] == 'base'
            )

            print(f"\nCollection: {len(games_found)}/{len(all_achievable)} total achievable "
                  f"({100 * len(games_found) / len(all_achievable):.1f}%)", file=sys.stderr)
            print(f"  Base games: {base_owned}/{base_achievable}", file=sys.stderr)
            print(f"  Missing: {len(missing_games)} titles = {missing_ach} achievements "
                  f"({missing_pts} points)", file=sys.stderr)

            if subsets_owned_base:
                print(f"  Subsets available (own base): {len(subsets_owned_base)} = "
                      f"{subset_ach} achievements ({subset_pts} points)", file=sys.stderr)

        # ROM info and patch download for missing games
        patch_dir = getattr(args, 'patch_dir', Path('./patches'))

        if rom_info_flag or download_patches_flag:
            # Convert missing_games to list format for get_rom_info_for_missing()
            missing_list = []
            for gid, info in sorted_missing:
                missing_list.append({
                    'title': info['title'],
                    'achievements': info['achievements'],
                    'points': info['points'],
                    'url': f"https://retroachievements.org/game/{gid}",
                    'hashes': info.get('hashes', []),
                })

            print(f"\nQuerying ROM info for {len(missing_list)} missing games...", file=sys.stderr)
            rom_info = get_rom_info_for_missing(missing_list, rate_limit=0.5, verbose=True)

            # Print report
            if rom_info_flag:
                local_hashes = {u['hash'] for u in unsupported if u.get('hash')}
                report = format_rom_info_report(rom_info, local_hashes)
                print(report)

            # Download patches
            if download_patches_flag:
                all_patches = []
                for g in rom_info['base_games']:
                    all_patches.extend(g.get('patches', []))
                for g in rom_info['hacks_with_patches']:
                    all_patches.extend(g.get('patches', []))

                if all_patches:
                    sys_name = get_system_name(system_id)
                    print(f"\nDownloading {len(all_patches)} patches to "
                          f"{patch_dir}/{sys_name}/...", file=sys.stderr)
                    success_count = 0
                    fail_count = 0
                    for patch in all_patches:
                        ok, msg = download_patch(patch['patch_url'], patch_dir, sys_name)
                        if ok:
                            success_count += 1
                        else:
                            fail_count += 1
                            print(f"  Failed: {msg}", file=sys.stderr)
                        time.sleep(0.3)  # Rate limit downloads
                    print(f"Patches: {success_count} downloaded, {fail_count} failed", file=sys.stderr)
                else:
                    print("No patches available to download.", file=sys.stderr)

            # Write missing list with expanded columns (ROM info was fetched)
            if missing_list_file:
                write_missing_list_expanded(
                    missing_list_file, sorted_missing, rom_info)
                print(f"MISSING list saved to: {missing_list_file}", file=sys.stderr)

        elif missing_list_file:
            # Write basic missing list (no ROM info)
            write_missing_list_basic(missing_list_file, sorted_missing)
            print(f"MISSING list saved to: {missing_list_file}", file=sys.stderr)

        # Run comparison if --compare flag was used
        if compare_flag and missing_list_file:
            # Determine compare directory
            if compare_flag is True:
                compare_dir = rom_dir  # Default to same ROM dir
            else:
                compare_dir = Path(compare_flag)

            if compare_dir.exists():
                run_compare(Path(missing_list_file), compare_dir, Path('.'))
            else:
                print(f"Warning: Compare directory not found: {compare_dir}", file=sys.stderr)

    # Offer to delete
    if delete_list and args.execute:
        print(f"\n  Deleting {len(delete_list)} duplicate ROMs...", file=sys.stderr)
        for p in delete_list:
            full_path = rom_dir / p
            if full_path.exists():
                full_path.unlink()
                print(f"  Deleted: {p}", file=sys.stderr)
        print("Done!", file=sys.stderr)
    elif delete_list and output_format == 'text':
        print("\nTo actually delete duplicates, run with --execute")
        print("Or manually delete files listed above")


def main():
    parser = argparse.ArgumentParser(
        description="RetroAchievements ROM Compatibility Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s setup                        # Download/install RAHasher
  %(prog)s setup --check                # Check if RAHasher is up to date
  %(prog)s setup --upgrade              # Force upgrade RAHasher
  %(prog)s systems                      # List all systems
  %(prog)s pull snes                    # Pull SNES hashes (by name)
  %(prog)s pull 3                       # Pull SNES hashes (by ID)
  %(prog)s check snes ~/roms/snes/      # Check SNES ROMs
  %(prog)s check snes ~/roms/ -s        # Check with summary only
  %(prog)s check psx ~/roms/psx/ -v     # Check PS1 ROMs with progress
  %(prog)s dedup snes ~/roms/snes/      # Find duplicates (human-readable)
  %(prog)s dedup snes ~/roms/ -s        # Quick summary only
  %(prog)s dedup snes ~/roms/ --missing # Show RA titles you're missing
  %(prog)s dedup snes ~/roms/ --missing-base-only  # Missing official games only
  %(prog)s dedup snes ~/roms/ --missing-list wanted.txt  # Export with hashes
  %(prog)s dedup snes ~/roms/ --copy-to ~/ra-roms/snes  # Copy to categorized folders
  %(prog)s dedup snes ~/roms/ --copy-to ~/ra-roms --copy-mode symlink  # Symlink instead
  %(prog)s dedup snes ~/roms/ -o report.txt    # Save report to file
  %(prog)s dedup snes ~/roms/ --format json -o results.json  # JSON to file
  %(prog)s dedup snes ~/roms/ --format csv     # CSV output for spreadsheets
  %(prog)s hash psx game.chd            # Hash a PS1 CHD file

System names accepted (examples):
  snes, "super nintendo", "super famicom", 3  (all equivalent)
  genesis, "mega drive", md, 1
  psx, ps1, playstation, 12
  gba, "game boy advance", 5

Environment Variables:
  RA_API_KEY  - RetroAchievements Web API Key (required)
  RA_HASHER   - Path to RAHasher executable (auto-detected if in PATH)

Cache:
  Systems list cached in ~/.cache/ra_tool/ra_systems.json (30 days)
  Hash databases cached in ~/.cache/ra_tool/ra_system_*.json (6 months)
        """
    )

    subparsers = parser.add_subparsers(dest='command', required=True)

    # setup command
    sub_setup = subparsers.add_parser('setup', help='Download and install RAHasher')
    sub_setup.add_argument('--upgrade', '-u', action='store_true',
                           help='Upgrade RAHasher even if already installed')
    sub_setup.add_argument('--check', '-c', action='store_true',
                           help='Just check version, don\'t install')
    sub_setup.set_defaults(func=cmd_setup)

    # systems command
    sub_systems = subparsers.add_parser('systems', help='List all RA systems')
    sub_systems.set_defaults(func=cmd_systems)

    # pull command
    sub_pull = subparsers.add_parser('pull', help='Pull hash database')
    sub_pull.add_argument('system', help='System ID, name, or "all"')
    sub_pull.add_argument('-f', '--force', action='store_true',
                          help='Force refresh even if cache is valid')
    sub_pull.set_defaults(func=cmd_pull)

    # check command
    sub_check = subparsers.add_parser(
        'check', help='Check ROMs against database (auto-pulls if needed)')
    sub_check.add_argument('system', help='System ID or name (e.g., 3, snes, "super nintendo")')
    sub_check.add_argument('rom_dir', help='ROM directory to scan')
    sub_check.add_argument('-v', '--verbose', action='store_true',
                           help='Show detailed output (RAHasher errors, no-achievement games)')
    sub_check.add_argument('-s', '--summary', action='store_true',
                           help='Show only summary (no full report)')
    sub_check.add_argument('-o', '--output', help='Output report to file')
    sub_check.add_argument('-f', '--force', action='store_true',
                           help='Force refresh hash database')
    sub_check.add_argument('--copy-to',
                           help='Copy ALL matched ROMs to destination (creates subfolders)')
    sub_check.add_argument('--copy-mode', choices=['copy', 'move', 'symlink'], default='copy',
                           help='Copy mode: copy (default), move, or symlink')
    sub_check.add_argument('--missing', action='store_true',
                           help='Show RA titles with achievements that you are missing')
    sub_check.add_argument('--missing-base-only', action='store_true',
                           help='Only show missing base games (no hacks/homebrews)')
    sub_check.add_argument('--missing-list', nargs='?', const=True, default=None,
                           help='Output missing list (default: {system}-missing.txt)')
    sub_check.add_argument('--rom-info', action='store_true',
                           help='Query hash pages for missing games to get ROM names & patch URLs')
    sub_check.add_argument('--download-patches', action='store_true',
                           help='Download patches for missing games (excludes non-English translations)')
    sub_check.add_argument('--patch-dir', type=Path, default=Path('./patches'),
                           help='Output directory for downloaded patches (default: ./patches)')
    sub_check.add_argument('--compare', nargs='?', const=True, default=None, metavar='ROM_DIR',
                           help='Compare missing against local ROMs (default: same dir)')
    sub_check.set_defaults(func=cmd_check)

    # dedup command
    sub_dedup = subparsers.add_parser(
        'dedup', help='RA-aware deduplication - recommend best ROM per game')
    sub_dedup.add_argument('system', help='System ID or name (e.g., 3, snes, "super nintendo")')
    sub_dedup.add_argument('rom_dir', help='ROM directory to scan')
    sub_dedup.add_argument('-v', '--verbose', action='store_true', help='Show detailed output (RAHasher errors)')
    sub_dedup.add_argument('-s', '--summary', action='store_true',
                           help='Show only summary (no full report)')
    sub_dedup.add_argument('-o', '--output', help='Output file (default: stdout)')
    sub_dedup.add_argument('-f', '--force', action='store_true',
                           help='Force refresh hash database')
    sub_dedup.add_argument('--format', choices=['text', 'json', 'csv'], default='text',
                           help='Output format: text (default), json, or csv')
    sub_dedup.add_argument('--missing', action='store_true',
                           help='Show RA titles you don\'t have (with achievements)')
    sub_dedup.add_argument('--missing-base-only', action='store_true',
                           help='Only show base games (exclude hacks, homebrew, subsets)')
    sub_dedup.add_argument('--missing-list', nargs='?', const=True, default=None,
                           help='Output missing list (default: {system}-missing.txt)')
    sub_dedup.add_argument('--rom-info', action='store_true',
                           help='Query hash pages for missing games to get ROM names & patch URLs')
    sub_dedup.add_argument('--download-patches', action='store_true',
                           help='Download patches for missing games (excludes non-English translations)')
    sub_dedup.add_argument('--patch-dir', type=Path, default=Path('./patches'),
                           help='Output directory for downloaded patches (default: ./patches)')
    sub_dedup.add_argument('--compare', nargs='?', const=True, default=None, metavar='ROM_DIR',
                           help='Compare missing against local ROMs (default: same dir)')
    sub_dedup.add_argument('--keep-list', help='Output file for ROMs to keep (one per line)')
    sub_dedup.add_argument('--delete-list', help='Output file for duplicate ROMs to delete')
    sub_dedup.add_argument('--unsupported-list', help='Output file for unsupported ROMs')
    sub_dedup.add_argument('--execute', action='store_true',
                           help='Actually delete duplicate files (DANGEROUS)')
    sub_dedup.add_argument('--copy-to',
                           help='Copy matched ROMs to destination (creates subfolders)')
    sub_dedup.add_argument('--copy-mode', choices=['copy', 'move', 'symlink'], default='copy',
                           help='How to transfer files: copy (default), move, or symlink')
    sub_dedup.set_defaults(func=cmd_dedup)

    # hash command
    sub_hash = subparsers.add_parser('hash', help='Hash a single file')
    sub_hash.add_argument('system', help='System ID or name')
    sub_hash.add_argument('file', help='File to hash')
    sub_hash.set_defaults(func=cmd_hash)

    # compare command
    sub_compare = subparsers.add_parser('compare',
                                        help='Compare missing list against local ROM collection')
    sub_compare.add_argument('missing_file', nargs='?',
                             help='Path to *-missing.txt file (or use --all)')
    sub_compare.add_argument('rom_dir', nargs='?',
                             help='ROM directory (auto-detected from filename if not specified)')
    sub_compare.add_argument('--all', action='store_true',
                             help='Process all *-missing.txt files in current directory')
    sub_compare.add_argument('--rom-base', type=Path, default=DEFAULT_ROM_BASE,
                             help=f'Base ROM directory for auto-detection (default: {DEFAULT_ROM_BASE})')
    sub_compare.add_argument('--threshold', type=int, default=COMPARE_MATCH_THRESHOLD,
                             help=f'Fuzzy match threshold 0-100 (default: {COMPARE_MATCH_THRESHOLD})')
    sub_compare.add_argument('--output-dir', '-o', type=Path, default=Path('.'),
                             help='Output directory for result files (default: current dir)')
    sub_compare.set_defaults(func=cmd_compare)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    main()
