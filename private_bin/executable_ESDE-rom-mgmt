#!/bin/bash
set -euo pipefail
IFS=$'\n\t'

# =============================================================================
# ES-DE ROM Management Script
# =============================================================================
# This script manages ROM files for ES-DE (EmulationStation Desktop Edition)
# by syncing from NAS, scraping metadata, and organizing media files.
#
# Author: Your Name
# Version: 2.0
# =============================================================================

# --- Global Variables ---
SCRIPT_NAME="$(basename "$0")"
VERBOSE=false
EXTENSION=""
NAS_MOUNT="$HOME/mnt/Games"
NAS_USER_RO="lolguest"
NAS_USER_RW="gamer"
NAS_IP="192.168.1.77"
NAS_SHARE="gamer"

# --- Help Function ---
show_help() {
    cat << EOF
ES-DE ROM Management Script v2.0

DESCRIPTION:
    Manages ROM files for ES-DE by syncing from NAS storage, scraping metadata
    using Skyscraper, and organizing media files. Supports two modes:
    
    • initialize: Full sync of all ROMs from NAS (replaces local content)
    • additions:  Processes new ROMs from '0merge' folder (requires 0merge directory)

USAGE:
    $SCRIPT_NAME [OPTIONS] <CONSOLE>

OPERATION MODES (choose one):
    -i, --initialize   Full ROM synchronization from NAS
                       - Mounts NAS read-only
                       - Syncs entire ROM collection (with --delete)
                       - Scrapes metadata for all ROMs
                       - Organizes media files
                       - Cleans up temporary files

    -a, --additions    Process new ROM additions from 0merge folder
                       - Requires '0merge' directory on NAS
                       - Syncs only new ROMs from 0merge
                       - Scrapes metadata for new ROMs only
                       - Merges gamelists (preserves existing entries)
                       - Moves ROMs from 0merge to main directory
                       - Syncs back to NAS (removes processed 0merge)

ARGUMENTS:
    <CONSOLE>          Console name (e.g., psx, n64, snes, genesis)
                       Must match directory names on both NAS and local storage

OTHER OPTIONS:
    -v, --verbose      Enable verbose output (detailed progress information)
    -e, --extension    Add file extension filter to Skyscraper commands
                       Example: -e "*.wua" for Wii U archives
    -h, --help         Show this help message and exit

DIRECTORY STRUCTURE:
    NAS (Remote):      ~/mnt/Games/Roms/<CONSOLE>/
                       ~/mnt/Games/Roms/<CONSOLE>/0merge/    (for additions mode)
                       ~/mnt/Games/Roms/<CONSOLE>/hacks/     (optional)
    
    Local:             ~/ROMs/<CONSOLE>/
    ES-DE Gamelists:   ~/ES-DE/gamelists/<CONSOLE>/
    ES-DE Media:       ~/ES-DE/downloaded_media/<CONSOLE>/

REQUIREMENTS:
    • NAS accessible at $NAS_IP (share: $NAS_SHARE)
    • Skyscraper installed and configured
    • CIFS utilities for NAS mounting
    • rsync for file synchronization
    • sudo access for NAS mounting

EXAMPLES:
    # Initialize PlayStation ROMs (full sync)
    $SCRIPT_NAME --initialize psx
    $SCRIPT_NAME -i psx

    # Add new Nintendo 64 ROMs from 0merge folder
    $SCRIPT_NAME --additions n64
    $SCRIPT_NAME -a n64

    # Initialize with verbose output and custom extension
    $SCRIPT_NAME -v -e "*.wua" --initialize wiiu

    # Process additions for SNES with verbose logging
    $SCRIPT_NAME --verbose --additions snes

NOTES:
    • '--additions' mode requires a '0merge' directory on the NAS
    • The script will create necessary local directories if they don't exist
    • Always creates backups of existing gamelists before modifications
    • Media files are organized according to ES-DE naming conventions
    • NAS is mounted read-only for safety, then remounted read-write when needed

EOF
}

# --- Logging Functions ---

# Log message with timestamp (always shown)
log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

# Log error message and exit
log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $*" >&2
    exit 1
}

# Log verbose message (only shown in verbose mode)
log_verbose() {
    if [[ "$VERBOSE" == true ]]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] VERBOSE: $*"
    fi
}

# --- Validation Functions ---

# Validate command line arguments
validate_arguments() {
    local mode="$1"
    local console="$2"

    if [[ -z "$mode" ]]; then
        echo "ERROR: No operation mode specified" >&2
        echo "Use '--initialize' or '--additions' to specify the operation mode" >&2
        echo "Use '$SCRIPT_NAME --help' for usage information" >&2
        exit 1
    fi

    if [[ -z "$console" ]]; then
        echo "ERROR: Missing console name argument" >&2
        echo "Use '$SCRIPT_NAME --help' for usage information" >&2
        exit 1
    fi

    if [[ ! "$mode" =~ ^(initialize|additions)$ ]]; then
        log_error "Invalid mode '$mode'. Must be 'initialize' or 'additions'"
    fi

    if [[ ! "$console" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log_error "Invalid console name '$console'. Use alphanumeric characters, hyphens, and underscores only"
    fi

    # Validate console name isn't too generic or dangerous
    case "$console" in
        ""|"home"|"root"|"tmp"|"var"|"usr"|"etc")
            log_error "Invalid console name '$console' - name is too generic or potentially dangerous"
            ;;
    esac
}

# --- NAS Management Functions ---

# Mount NAS with specified user and permissions
mount_nas() {
    local nas_user="$1"
    local mount_options="$2"
    
    if ! grep -qs "$NAS_MOUNT" /proc/mounts; then
        log_info "Mounting NAS as user '$nas_user'..."
        log_verbose "Mount command: mount -t cifs '//$NAS_IP/$NAS_SHARE' '$NAS_MOUNT' -o $mount_options"
        
        if ! sudo mount -t cifs "//$NAS_IP/$NAS_SHARE" "$NAS_MOUNT" -o "$mount_options"; then
            log_error "Failed to mount NAS at $NAS_MOUNT"
        fi
        
        log_info "NAS mounted successfully"
    else
        log_info "NAS already mounted"
        log_verbose "Mount point: $NAS_MOUNT"
    fi
}

# Unmount NAS safely
unmount_nas() {
    if grep -qs "$NAS_MOUNT" /proc/mounts; then
        log_info "Unmounting NAS..."
        if sudo umount "$NAS_MOUNT"; then
            log_info "NAS unmounted successfully"
        else
            log_error "Failed to unmount NAS"
        fi
    else
        log_verbose "NAS not mounted, nothing to unmount"
    fi
}

# --- Path Validation Functions ---

# Validate that required directories exist
validate_paths() {
    local console="$1"
    local mode="$2"
    
    local nas_rom_dir="$NAS_MOUNT/Roms/$console"
    local local_rom_dir="$HOME/ROMs/$console"
    
    log_verbose "Validating directory paths for console: $console"
    
    # Check NAS ROM directory
    if [[ ! -d "$nas_rom_dir" ]]; then
        log_error "NAS ROM directory not found: $nas_rom_dir"
    fi
    log_verbose "✓ NAS ROM directory exists: $nas_rom_dir"
    
    # For initialize mode, local directory will be created/synced
    # For additions mode, local directory must exist
    if [[ "$mode" == "additions" ]] && [[ ! -d "$local_rom_dir" ]]; then
        log_error "Local ROM directory not found: $local_rom_dir (required for additions mode)"
    elif [[ "$mode" == "initialize" ]]; then
        # Create local ROM directory if it doesn't exist
        mkdir -p "$local_rom_dir"
        log_verbose "✓ Local ROM directory ready: $local_rom_dir"
    else
        log_verbose "✓ Local ROM directory exists: $local_rom_dir"
    fi
    
    # For additions mode, check for 0merge directory
    if [[ "$mode" == "additions" ]]; then
        local merge_dir="$nas_rom_dir/0merge"
        if [[ ! -d "$merge_dir" ]]; then
            log_error "0merge directory not found: $merge_dir (required for additions mode)"
        fi
        log_verbose "✓ 0merge directory exists: $merge_dir"
    fi
    
    log_info "✓ All required directories validated"
}

# --- Skyscraper Functions ---

# Run Skyscraper metadata scraping with optional extension
scrape_metadata() {
    local console="$1"
    local input_dir="$2"
    shift 2
    local extension_args=("$@")  # Use array for extension arguments
    
    log_info "Running Skyscraper metadata scrapes for $console..."
    log_verbose "Input directory: $input_dir"
    log_verbose "Extension args: ${extension_args[*]:-none}"
    
    # ES gamelist scrape (existing metadata)
    log_verbose "Scraping ES gamelist metadata..."
    Skyscraper -p "$console" -s esgamelist -i "$input_dir" \
        --flags videos,relative,nosubdirs,unattend --refresh "${extension_args[@]}"
    
    # ScreenScraper database scrape
    log_verbose "Scraping ScreenScraper database..."
    Skyscraper -p "$console" -s screenscraper -i "$input_dir" \
        --flags noscreenshots,nocovers,nowheels,nomarquees,nosubdirs,unattend "${extension_args[@]}"
    
    # TheGamesDB scrape
    log_verbose "Scraping TheGamesDB database..."
    Skyscraper -p "$console" -s thegamesdb -i "$input_dir" \
        --flags nosubdirs,unattend "${extension_args[@]}"
    
    # Generate final gamelist
    log_verbose "Generating final gamelist..."
    Skyscraper -p "$console" -i "$input_dir" \
        --flags unattend,relative "${extension_args[@]}"
    
    log_info "✓ Metadata scraping completed"
}

# --- Gamelist Management Functions ---

# Sync gamelist for initialize mode (replace)
sync_gamelist_replace() {
    local console="$1"
    local source_dir="$2"
    
    local es_gamelist="$HOME/ES-DE/gamelists/$console"
    local source_gamelist="$source_dir/gamelist.xml"
    local target_gamelist="$es_gamelist/gamelist.xml"
    
    log_info "Syncing gamelist (replace mode)..."
    
    mkdir -p "$es_gamelist"
    
    # Backup existing gamelist if it exists
    if [[ -f "$target_gamelist" ]]; then
        cp "$target_gamelist" "$es_gamelist/gamelist-backup.xml"
        log_verbose "✓ Created gamelist backup"
    fi
    
    # Copy new gamelist
    if [[ -f "$source_gamelist" ]]; then
        rsync "$source_gamelist" "$target_gamelist"
        log_info "✓ Gamelist synced successfully"
    else
        log_error "Source gamelist not found: $source_gamelist"
    fi
}

# Merge gamelist for additions mode (append)
sync_gamelist_merge() {
    local console="$1"
    local source_dir="$2"
    
    local es_gamelist="$HOME/ES-DE/gamelists/$console"
    local source_gamelist="$source_dir/gamelist.xml"
    local target_gamelist="$es_gamelist/gamelist.xml"
    local merge_gamelist="$es_gamelist/gamelist-merge.xml"
    
    log_info "Merging gamelist (additions mode)..."
    
    mkdir -p "$es_gamelist"
    
    if [[ ! -f "$source_gamelist" ]]; then
        log_error "Source gamelist not found: $source_gamelist"
    fi
    
    # Prepare source gamelist for merging (remove XML headers and root tags)
    sed -i '/gameList/d;/xml version/d' "$source_gamelist"
    
    # Backup existing gamelist
    if [[ -f "$target_gamelist" ]]; then
        cp "$target_gamelist" "$es_gamelist/gamelist-backup.xml"
        log_verbose "✓ Created gamelist backup"
    else
        # Create empty gamelist if none exists
        cat > "$target_gamelist" << EOF
<?xml version="1.0"?>
<gameList>
</gameList>
EOF
        log_verbose "✓ Created new empty gamelist"
    fi
    
    # Merge gamelists
    cat "$target_gamelist" "$source_gamelist" > "$merge_gamelist"
    
    # Clean up merged gamelist (remove closing tags, fix paths)
    sed -i '/\/gameList/d;s/\/0merge//' "$merge_gamelist"
    echo "</gameList>" >> "$merge_gamelist"
    
    # Replace original with merged version
    mv "$merge_gamelist" "$target_gamelist"
    
    log_info "✓ Gamelist merged successfully"
}

# --- Media Management Functions ---

# Sync media files using the media mapping
sync_media_files() {
    local console="$1"
    local source_dir="$2"
    local mode="$3"  # "copy" for additions, "rsync" for initialize
    
    log_info "Syncing media files ($mode mode)..."
    
    local es_media="$HOME/ES-DE/downloaded_media/$console"
    mkdir -p "$es_media"
    
    # Define media type mapping (Skyscraper -> ES-DE)
    declare -A media_map=(
        [box2dback]=backcovers
        [box2dfront]=covers
        [box3d]=3dboxes
        [fanart]=fanart
        [images]=miximages
        [manual]=manuals
        [screenshot]=screenshots
        [screenshottitle]=titlescreens
        [support]=physicalmedia
        [videos]=videos
        [wheel]=marquees
    )
    
    for src_type in "${!media_map[@]}"; do
        local src_path="$source_dir/media/$src_type"
        local dest_type="${media_map[$src_type]}"
        local dest_path="$es_media/$dest_type"
        
        if [[ -d "$src_path" ]]; then
            mkdir -p "$dest_path"
            
            if [[ "$mode" == "copy" ]]; then
                # For additions mode, copy files
                if cp -r "$src_path"/* "$dest_path" 2>/dev/null; then
                    log_verbose "✓ Copied $src_type -> $dest_type"
                else
                    log_verbose "• No files to copy for $src_type"
                fi
            elif [[ "$mode" == "rsync" ]]; then
                # For initialize mode, sync with rsync
                if [[ "$VERBOSE" == true ]]; then
                    rsync -avz --info=progress2 "$src_path/" "$dest_path"
                else
                    rsync -az "$src_path/" "$dest_path"
                fi
                log_verbose "✓ Synced $src_type -> $dest_type"
            fi
        else
            log_verbose "• Skipping missing media type: $src_type"
        fi
    done
    
    log_info "✓ Media files synced successfully"
}

# --- Cleanup Functions ---

# Clean up temporary files and directories
cleanup_temp_files() {
    local cleanup_dir="$1"
    local description="$2"
    
    log_info "Cleaning up $description..."
    
    # Remove media directory
    if [[ -d "${cleanup_dir:?}/media" ]]; then
        rm -rf "${cleanup_dir:?}/media"
        log_verbose "✓ Removed media directory"
    else
        log_verbose "• No media directory to remove"
    fi
    
    # Remove gamelist files
    shopt -s nullglob
    local gamelist_files=("${cleanup_dir:?}"/gamelist.*)
    if (( ${#gamelist_files[@]} )); then
        rm -f "${gamelist_files[@]}"
        log_verbose "✓ Removed ${#gamelist_files[@]} gamelist file(s)"
    else
        log_verbose "• No gamelist files to remove"
    fi
    shopt -u nullglob
    
    log_info "✓ Cleanup completed"
}

# Move all files including dotfiles
move_all_contents() {
    local src="$1"
    local dst="$2"
    
    log_verbose "Moving contents from $src to $dst"
    
    if [[ ! -d "$src" ]]; then
        log_error "Source directory not found: $src"
    fi
    
    mkdir -p "$dst"
    
    shopt -s dotglob nullglob
    local files=("$src"/*)
    if (( ${#files[@]} )); then
        mv "$src"/* "$dst"/
        log_verbose "✓ Moved ${#files[@]} items"
    else
        log_verbose "• No files to move"
    fi
    shopt -u dotglob nullglob
}

# --- Main Mode Functions ---

# Initialize mode: Full ROM synchronization
mode_initialize() {
    local console="$1"
    shift
    local extension_args=("$@")
    
    log_info "=== INITIALIZE MODE: $console ==="
    
    local nas_rom_dir="$NAS_MOUNT/Roms/$console"
    local local_rom_dir="$HOME/ROMs/$console"
    
    # Mount NAS read-only
    mount_nas "$NAS_USER_RO" "user=$NAS_USER_RO,vers=2.0,ro"
    
    # Validate paths
    validate_paths "$console" "initialize"
    
    # Sync all ROMs from NAS (with delete to match exactly)
    log_info "Syncing ROMs from NAS (with --delete)..."
    if [[ "$VERBOSE" == true ]]; then
        rsync -avz --info=progress2 "$nas_rom_dir/" "$local_rom_dir" --delete
    else
        rsync -az "$nas_rom_dir/" "$local_rom_dir" --delete
    fi
    log_info "✓ ROM sync completed"
    
    # Scrape metadata
    scrape_metadata "$console" "$local_rom_dir" "${extension_args[@]}"
    
    # Sync gamelist (replace)
    sync_gamelist_replace "$console" "$local_rom_dir"
    
    # Sync media files
    sync_media_files "$console" "$local_rom_dir" "rsync"
    
    # Cleanup
    cleanup_temp_files "$local_rom_dir" "local ROM directory"
    
    log_info "✅ ROM initialization complete for console: $console"
}

# Additions mode: Process new ROMs from 0merge
mode_additions() {
    local console="$1"
    shift
    local extension_args=("$@")
    
    log_info "=== ADDITIONS MODE: $console ==="
    
    local nas_rom_dir="$NAS_MOUNT/Roms/$console"
    local nas_merge_dir="$nas_rom_dir/0merge"
    local local_rom_dir="$HOME/ROMs/$console"
    local local_merge_dir="$local_rom_dir/0merge"
    
    # Mount NAS read-only initially
    mount_nas "$NAS_USER_RO" "user=$NAS_USER_RO,vers=2.0,ro"
    
    # Validate paths
    validate_paths "$console" "additions"
    
    # Process 0merge directory
    log_info "Processing 0merge directory..."
    if [[ "$VERBOSE" == true ]]; then
        rsync -avz --info=progress2 "$nas_merge_dir/" "$local_merge_dir"
    else
        rsync -az "$nas_merge_dir/" "$local_merge_dir"
    fi
    log_info "✓ 0merge directory synced"
    
    # Scrape metadata for new ROMs
    scrape_metadata "$console" "$local_merge_dir" "${extension_args[@]}"
    
    # Merge gamelist
    sync_gamelist_merge "$console" "$local_merge_dir"
    
    # Sync media files (copy mode)
    sync_media_files "$console" "$local_merge_dir" "copy"
    
    # Clean up 0merge temporary files
    cleanup_temp_files "$local_merge_dir" "0merge directory"
    
    # Move ROMs to main directory
    log_info "Moving ROMs to main directory..."
    move_all_contents "$local_merge_dir" "$local_rom_dir"
    
    # Remove 0merge if empty
    if [[ -z "$(ls -A "$local_merge_dir" 2>/dev/null || true)" ]]; then
        rm -rf "${local_merge_dir:?}"
        log_info "✓ Removed empty 0merge directory"
    else
        log_info "⚠️  0merge directory not empty - inspect manually: $local_merge_dir"
    fi
    
    # Handle hacks folder if present
    if [[ -d "$nas_rom_dir/hacks" ]]; then
        log_info "Syncing hacks directory..."
        local hacks_dir="$local_rom_dir/hacks"
        if [[ "$VERBOSE" == true ]]; then
            rsync -avz --info=progress2 "$nas_rom_dir/hacks/" "$hacks_dir/" --delete
        else
            rsync -az "$nas_rom_dir/hacks/" "$hacks_dir/" --delete
        fi
        # Remove any gamelist from hacks directory
        rm -f "$hacks_dir/gamelist.xml"
        log_info "✓ Hacks directory synced"
    else
        log_verbose "• No hacks directory found"
    fi
    
    # Remount NAS as read-write for cleanup
    log_info "Remounting NAS as read-write for cleanup..."
    unmount_nas
    mount_nas "$NAS_USER_RW" "user=$NAS_USER_RW,vers=2.0"
    
    # Clean up NAS 0merge directory
    log_info "Cleaning up NAS 0merge directory..."
    sudo rm -f "$nas_merge_dir"/gamelist.*
    
    # Move any remaining files from 0merge to main directory on NAS
    shopt -s dotglob nullglob
    local remaining_files=("$nas_merge_dir"/*)
    if (( ${#remaining_files[@]} )); then
        sudo mv "$nas_merge_dir"/* "$nas_rom_dir"/ 2>/dev/null || true
        log_verbose "• Moved ${#remaining_files[@]} remaining files"
    fi
    shopt -u dotglob nullglob
    
    # Remove 0merge from NAS if empty
    if [[ -z "$(ls -A "$nas_merge_dir" 2>/dev/null || true)" ]]; then
        sudo rm -rf "$nas_merge_dir"
        log_info "✓ Removed empty 0merge directory from NAS"
    else
        log_info "⚠️  NAS 0merge directory not empty - inspect manually: $nas_merge_dir"
    fi
    
    # Unmount NAS
    unmount_nas
    
    log_info "✅ ROM additions complete for console: $console"
}

# --- Main Script ---

main() {
    # Parse command line arguments
    local mode=""
    local console=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -i|--initialize)
                if [[ -n "$mode" ]]; then
                    log_error "Cannot specify both --initialize and --additions modes"
                fi
                mode="initialize"
                log_verbose "Initialize mode selected"
                shift
                ;;
            -a|--additions)
                if [[ -n "$mode" ]]; then
                    log_error "Cannot specify both --initialize and --additions modes"
                fi
                mode="additions"
                log_verbose "Additions mode selected"
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                log_verbose "Verbose mode enabled"
                shift
                ;;
            -e|--extension)
                if [[ -n "${2:-}" ]]; then
                    EXTENSION="$2"
                    log_verbose "Extension filter set: $EXTENSION"
                    shift 2
                else
                    log_error "Extension option requires an argument"
                fi
                ;;
            -*)
                log_error "Unknown option: $1"
                ;;
            *)
                if [[ -z "$console" ]]; then
                    console="$1"
                else
                    log_error "Too many arguments"
                fi
                shift
                ;;
        esac
    done
    
    # Show help if no arguments provided
    if [[ -z "$mode" ]] && [[ -z "$console" ]]; then
        show_help
        exit 0
    fi
    
    # Validate arguments
    validate_arguments "$mode" "$console"
    
    # Prepare extension arguments for Skyscraper
    local extension_args=()
    if [[ -n "$EXTENSION" ]]; then
        extension_args=("--addext" "$EXTENSION")
        log_info "Using extension filter: $EXTENSION"
    fi
    
    # Create mount point if it doesn't exist
    mkdir -p "$NAS_MOUNT"
    
    # Execute appropriate mode
    case "$mode" in
        initialize)
            mode_initialize "$console" "${extension_args[@]}"
            ;;
        additions)
            mode_additions "$console" "${extension_args[@]}"
            ;;
        *)
            log_error "Invalid mode: $mode"
            ;;
    esac
}

# --- Script Entry Point ---

# Trap to ensure NAS is unmounted on script exit
trap 'unmount_nas 2>/dev/null || true' EXIT

# Run main function with all arguments
main "$@"
