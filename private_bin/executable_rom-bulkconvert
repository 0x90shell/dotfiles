#!/usr/bin/env bash
# rom-bulkconvert - Recursively convert disc images to CHD or RVZ
#
# Supported conversions:
#   .iso (GameCube/Wii) -> RVZ (via DolphinTool, zstd compression)
#   .iso (other)        -> CHD (via chdman createdvd, zstd compression)
#   .cue                -> CHD (via chdman createcd, zstd compression)
#   .gdi                -> CHD (via chdman createcd, zstd compression)
#
# Compression:
#   CHD DVD: zstd,zlib,huff,flac  (fast decompression, ~2% larger than lzma)
#   CHD CD:  cdzs,cdzl,cdfl       (zstd for CD sectors)
#   RVZ:     zstd level 22        (DolphinTool default)
#
# Progress:
#   Non-verbose: single-line progress bar with adaptive ETA
#   Verbose (-v): header line + tool's native progress output

set -euo pipefail

usage() {
  cat <<EOF
Usage: $(basename "$0") [-v] [-h] [directory]

Recursively convert disc images to CHD (chdman) or RVZ (DolphinTool).

Options:
  -v          Verbose mode - show tool output instead of progress bar
  -h          Show this help message

Arguments:
  directory   Directory to scan (default: current directory)

Supported formats:
  .iso        -> .chd (DVD) or .rvz (GameCube/Wii)
  .cue        -> .chd (CD, preserves multi-track)
  .gdi        -> .chd (Dreamcast GDI)

Compression settings:
  DVD/ISO:    chdman createdvd -c zstd,zlib,huff,flac
  CD/CUE/GDI: chdman createcd -c cdzs,cdzl,cdfl
  GC/Wii:     DolphinTool -c zstd -l 22

Requirements:
  chdman      Required for CHD conversion (from MAME)
  DolphinTool Optional for GameCube/Wii RVZ conversion

Notes:
  - Skips files that already have corresponding output
  - ZSTD compression: ~3x faster decompression, ~2% larger than LZMA
  - Compatible with RetroArch, PCSX2, PPSSPP, Flycast, DuckStation
EOF
  exit 0
}

ROOT="."
VERBOSE=0
RVZ_COMPRESSION="zstd"
RVZ_LEVEL=22
RVZ_BLOCK_SIZE=131072

while getopts ":vh" opt; do
  case "$opt" in
    v) VERBOSE=1 ;;
    h) usage ;;
    *) ;;
  esac
done
shift $((OPTIND-1))
ROOT="${1:-$ROOT}"

command -v chdman >/dev/null 2>&1 || {
  echo "Error: chdman not found in PATH." >&2
  exit 1
}

# Check for DolphinTool (optional, only needed if GC/Wii ISOs are present)
DOLPHIN_TOOL=""
if command -v DolphinTool >/dev/null 2>&1; then
  DOLPHIN_TOOL="DolphinTool"
elif command -v dolphin-tool >/dev/null 2>&1; then
  DOLPHIN_TOOL="dolphin-tool"
fi

export LC_ALL=C

# ---------- helpers ----------
hsize() {
  local bytes
  bytes=${1:-0}
  if command -v numfmt >/dev/null 2>&1; then
    numfmt --to=iec --suffix=B --format="%.1f" "$bytes"
  else
    local i
    local units=(B KiB MiB GiB TiB)
    i=0
    while (( bytes >= 1024 && i < ${#units[@]}-1 )); do
      bytes=$((bytes/1024))
      ((i++))
    done
    printf "%d%s" "$bytes" "${units[$i]}"
  fi
}

# Detect GameCube/Wii ISO by magic bytes
# GC magic at 0x1C: 0xC2339F3D
# Wii magic at 0x18: 0x5D1C9EA3
iso_platform() {
  local iso="$1"
  local hdr
  
  # Read first 32 bytes
  hdr=$(xxd -l 32 -p "$iso" 2>/dev/null | tr -d '\n')
  
  # Check GC magic at offset 0x1C (hex chars 56-63)
  if [[ "${hdr:56:8}" == "c2339f3d" ]]; then
    echo "gc"
    return
  fi
  
  # Check Wii magic at offset 0x18 (hex chars 48-55)
  if [[ "${hdr:48:8}" == "5d1c9ea3" ]]; then
    echo "wii"
    return
  fi
  
  echo "dvd"
}

cue_bytes() {
  local cue
  cue="$1"
  local dir
  dir=$(dirname "$cue")
  awk '
    BEGIN{IGNORECASE=1}
    /^FILE[[:space:]]+/ {
      # Handle quoted filenames
      if (match($0, /FILE[[:space:]]+["]([^"]+)["]/, m)) {
        print m[1]
      } else {
        # Handle unquoted filenames
        sub(/^FILE[[:space:]]+/, "", $0)
        fname=$0
        sub(/[[:space:]]+(BINARY|WAVE|MP3|AIFF|FLAC).*$/,"",fname)
        print fname
      }
    }' "$cue" | while IFS= read -r rel; do
      stat -c%s -- "$dir/$rel" 2>/dev/null || echo 0
    done | awk '{s+=$1} END{print s+0}'
}

gdi_bytes() {
  local gdi
  gdi="$1"
  local dir
  dir=$(dirname "$gdi")
  awk 'NR>1 {print $5}' "$gdi" | while IFS= read -r rel; do
    stat -c%s -- "$dir/$rel" 2>/dev/null || echo 0
  done | awk '{s+=$1} END{print s+0}'
}

iso_bytes() { stat -c%s -- "$1" 2>/dev/null || echo 0; }

term_cols() { printf "%s" "${COLUMNS:-$(tput cols 2>/dev/null || echo 80)}"; }

# Get conversion type display string
get_conv_type() {
  local typ
  typ="$1"
  
  case "$typ" in
    gc)  echo "GC→RVZ" ;;
    wii) echo "Wii→RVZ" ;;
    dvd) echo "DVD→CHD" ;;
    cd)  echo "CD→CHD" ;;
    gdi) echo "GDI→CHD" ;;
    *)   echo "→CHD" ;;
  esac
}

print_bar() {
  local pct done_bytes total_bytes eta_s cur_idx nfiles fname conv_type
  pct=$1; done_bytes=$2; total_bytes=$3; eta_s=$4; cur_idx=$5; nfiles=$6; fname="$7"; conv_type="$8"

  local cols
  cols=$(term_cols)

  local width filled empty bar hashes dots
  width=40
  filled=$(( pct*width/100 ))
  (( filled < 0 )) && filled=0
  (( filled > width )) && filled=$width
  empty=$(( width - filled ))

  printf -v hashes '%*s' "$filled" ''
  hashes=${hashes// /#}
  printf -v dots '%*s' "$empty" ''
  dots=${dots// /.}
  bar="${hashes}${dots}"

  local h m s line maxw
  h=$(( eta_s/3600 ))
  m=$(( (eta_s%3600)/60 ))
  s=$(( eta_s%60 ))
  line=$(printf "[%s] %3d%% | %s / %s | ETA %02d:%02d:%02d | %d/%d | %s | %s" \
        "$bar" "$pct" "$(hsize "$done_bytes")" "$(hsize "$total_bytes")" \
        "$h" "$m" "$s" "$cur_idx" "$nfiles" "$conv_type" "$fname")

  maxw=$(( cols - 1 ))
  if (( ${#line} > maxw )); then
    local prefix room fname_only shown
    prefix="${line% | *}"
    if [[ "$prefix" == "$line" ]]; then
      prefix=$(printf "[%s] %3d%% | %s / %s | ETA %02d:%02d:%02d | %d/%d | %s | " \
        "$bar" "$pct" "$(hsize "$done_bytes")" "$(hsize "$total_bytes")" "$h" "$m" "$s" "$cur_idx" "$nfiles" "$conv_type")
    fi
    room=$(( maxw - ${#prefix} - 1 ))
    (( room < 5 )) && room=5
    fname_only="${line##* | }"
    shown="$fname_only"
    if (( ${#fname_only} > room )); then
      shown="${fname_only:0:room-1}…"
    fi
    line="${prefix} ${shown}"
    (( ${#line} > maxw )) && line="${line:0:maxw}"
  fi

  printf "\r\033[2K%s" "$line"
}

quote_cmd() {
  local out="" a
  for a in "$@"; do
    printf -v a '%q' "$a"
    out+="$a "
  done
  printf "%s" "$out"
}

# Run chdman in a PTY so it keeps its own progress bar.
# Strip the first banner line if present, pass everything else raw.
run_chdman_verbose() {
  local typ src out
  typ="$1"; src="$2"; out="$3"

  local cmd
  if [[ "$typ" == "dvd" ]]; then
    cmd=(chdman createdvd -c "zstd,zlib,huff,flac" -i "$src" -o "$out")
  else
    cmd=(chdman createcd -c "cdzs,cdzl,cdfl" -i "$src" -o "$out")
  fi

  local cmd_str
  cmd_str=$(quote_cmd "${cmd[@]}")

  if command -v script >/dev/null 2>&1; then
    set +o pipefail
    {
      script -qe -c "$cmd_str" /dev/null
    } | {
      IFS= read -r first || true
      if [[ "$first" != chdman\ -* ]]; then
        printf '%s\n' "$first"
      fi
      cat
    }
    local ec=${PIPESTATUS[0]}
    set -o pipefail
    return "$ec"
  else
    "${cmd[@]}"
  fi
}

# Run DolphinTool for RVZ conversion (verbose mode)
run_dolphin_verbose() {
  local src out
  src="$1"; out="$2"

  local cmd
  cmd=("$DOLPHIN_TOOL" convert -i "$src" -o "$out" -f rvz -c "$RVZ_COMPRESSION" -l "$RVZ_LEVEL" -b "$RVZ_BLOCK_SIZE")

  local cmd_str
  cmd_str=$(quote_cmd "${cmd[@]}")

  if command -v script >/dev/null 2>&1; then
    set +o pipefail
    script -qe -c "$cmd_str" /dev/null
    local ec=$?
    set -o pipefail
    return "$ec"
  else
    "${cmd[@]}"
  fi
}

# ---------- collect work ----------
declare -a SRC PATHS TYPES BYTES OUTS
SRC=(); PATHS=(); TYPES=(); BYTES=(); OUTS=()

# Track GC/Wii ISOs that need DolphinTool
declare -a SKIPPED_NO_DOLPHIN
SKIPPED_NO_DOLPHIN=()

mapfile -d '' PATHS < <(find "$ROOT" -type f \( -iname '*.cue' -o -iname '*.gdi' -o -iname '*.iso' \) -print0)

for src in "${PATHS[@]}"; do
  ext_lc="${src##*.}"; ext_lc="${ext_lc,,}"
  
  case "$ext_lc" in
    iso)
      platform=$(iso_platform "$src")
      case "$platform" in
        gc|wii)
          out="${src%.*}.rvz"
          [[ -e "$out" ]] && continue
          if [[ -z "$DOLPHIN_TOOL" ]]; then
            SKIPPED_NO_DOLPHIN+=("$src")
            continue
          fi
          TYPES+=("$platform")
          BYTES+=("$(iso_bytes "$src")")
          ;;
        *)
          out="${src%.*}.chd"
          [[ -e "$out" ]] && continue
          TYPES+=("dvd")
          BYTES+=("$(iso_bytes "$src")")
          ;;
      esac
      ;;
    cue)
      out="${src%.*}.chd"
      [[ -e "$out" ]] && continue
      TYPES+=("cd")
      BYTES+=("$(cue_bytes "$src")")
      ;;
    gdi)
      out="${src%.*}.chd"
      [[ -e "$out" ]] && continue
      TYPES+=("gdi")
      BYTES+=("$(gdi_bytes "$src")")
      ;;
    *)
      continue
      ;;
  esac
  OUTS+=("$out"); SRC+=("$src")
done

n=${#SRC[@]}

# Report skipped GC/Wii ISOs
if (( ${#SKIPPED_NO_DOLPHIN[@]} > 0 )); then
  echo "Warning: DolphinTool not found. Skipping ${#SKIPPED_NO_DOLPHIN[@]} GameCube/Wii ISO(s):"
  for f in "${SKIPPED_NO_DOLPHIN[@]}"; do
    echo "  - $(basename "$f")"
  done
  echo "Install DolphinTool to convert these to RVZ format."
  echo
fi

if (( n == 0 )); then
  echo "Nothing to do. No convertible images without existing output found."
  exit 0
fi

total_bytes=0
for b in "${BYTES[@]}"; do total_bytes=$(( total_bytes + b )); done

if (( VERBOSE )); then
  echo "Planned conversions: $n files, $(hsize "$total_bytes") total."
  echo "RVZ settings: $RVZ_COMPRESSION level $RVZ_LEVEL, block size $RVZ_BLOCK_SIZE"
fi

# ---------- run ----------
if (( VERBOSE == 0 )); then
  trap 'show_results' EXIT
  tput civis >/dev/null 2>&1 || true
fi

start_ts=$(date +%s)
done_bytes=0
last_global_pct=-1

# Track failed conversions
declare -a FAILED_CONVERSIONS
FAILED_CONVERSIONS=()

# Function to show results
show_results() {
  if (( VERBOSE == 0 )); then
    echo
    tput cnorm >/dev/null 2>&1 || true
  fi

  # Report results (always show, regardless of verbose mode)
  local total=${#SRC[@]}
  if (( total > 0 )); then
    local successful=$((total - ${#FAILED_CONVERSIONS[@]}))
    local failed_count=${#FAILED_CONVERSIONS[@]}
    if (( failed_count > 0 )); then
      echo "Completed: $successful/$total conversions successful."
      echo
      echo "Failed conversions:"
      for failed_file in "${FAILED_CONVERSIONS[@]}"; do
        echo "  - $(basename "$failed_file")"
      done
    else
      echo "Done. All $total conversions completed successfully."
    fi
  fi
}

# Set trap to always show results
trap 'show_results' EXIT

for i in "${!SRC[@]}"; do
  src="${SRC[$i]}"; out="${OUTS[$i]}"; typ="${TYPES[$i]}"; fbytes=${BYTES[$i]}
  base="$(basename "$src")"
  conv_type=$(get_conv_type "$typ")

  if (( VERBOSE )); then
    # Print the same one-line header as non-verbose, then newline so tool's live bar follows
    now=$(date +%s); elapsed=$(( now - start_ts ))
    prog_bytes=$done_bytes
    eta=$(( prog_bytes > 0 ? elapsed * (total_bytes - prog_bytes) / prog_bytes : 0 ))
    global_pct=$(( (prog_bytes*100)/total_bytes ))
    print_bar "$global_pct" "$prog_bytes" "$total_bytes" "$eta" $((i+1)) "$n" "$base" "$conv_type"
    printf "\n"

    case "$typ" in
      gc|wii)
        if run_dolphin_verbose "$src" "$out"; then
          done_bytes=$(( done_bytes + fbytes ))
        else
          FAILED_CONVERSIONS+=("$src")
          [[ -f "$out" ]] && rm -f "$out"
        fi
        ;;
      *)
        if run_chdman_verbose "$typ" "$src" "$out"; then
          done_bytes=$(( done_bytes + fbytes ))
        else
          FAILED_CONVERSIONS+=("$src")
          [[ -f "$out" ]] && rm -f "$out"
        fi
        ;;
    esac
    continue
  fi

  # Non-verbose progress
  now=$(date +%s); elapsed=$(( now - start_ts ))
  prog_bytes=$done_bytes
  eta=$(( prog_bytes > 0 ? elapsed * (total_bytes - prog_bytes) / prog_bytes : 0 ))
  global_pct=$(( (prog_bytes*100)/total_bytes ))
  print_bar "$global_pct" "$prog_bytes" "$total_bytes" "$eta" $((i+1)) "$n" "$base" "$conv_type"
  last_global_pct=$global_pct

  # Convert using appropriate method
  conversion_success=0
  
  case "$typ" in
    gc|wii)
      # GameCube/Wii -> RVZ via DolphinTool
      set +e
      "$DOLPHIN_TOOL" convert -i "$src" -o "$out" -f rvz -c "$RVZ_COMPRESSION" -l "$RVZ_LEVEL" -b "$RVZ_BLOCK_SIZE" 2>&1 | while IFS= read -r line; do
        if [[ "$line" =~ ([0-9]{1,3})% ]]; then
          p="${BASH_REMATCH[1]}"
          (( p > 100 )) && p=100
          now=$(date +%s); elapsed=$(( now - start_ts ))
          prog_bytes=$(( done_bytes + fbytes*p/100 ))
          global_pct=$(( (prog_bytes*100)/total_bytes ))
          if (( global_pct != last_global_pct )); then
            eta=$(( prog_bytes > 0 ? elapsed * (total_bytes - prog_bytes) / prog_bytes : 0 ))
            print_bar "$global_pct" "$prog_bytes" "$total_bytes" "$eta" $((i+1)) "$n" "$base" "$conv_type"
            last_global_pct=$global_pct
          fi
        fi
      done
      cmd_exit_code=$?
      set -e
      (( cmd_exit_code == 0 )) && conversion_success=1
      ;;
    dvd)
      # DVD/ISO conversion
      set +e
      chdman createdvd -c "zstd,zlib,huff,flac" -i "$src" -o "$out" 2>&1 | while IFS= read -r line; do
        if [[ "$line" =~ ([0-9]{1,3})% ]]; then
          p="${BASH_REMATCH[1]}"
          (( p > 100 )) && p=100
          now=$(date +%s); elapsed=$(( now - start_ts ))
          prog_bytes=$(( done_bytes + fbytes*p/100 ))
          global_pct=$(( (prog_bytes*100)/total_bytes ))
          if (( global_pct != last_global_pct )); then
            eta=$(( prog_bytes > 0 ? elapsed * (total_bytes - prog_bytes) / prog_bytes : 0 ))
            print_bar "$global_pct" "$prog_bytes" "$total_bytes" "$eta" $((i+1)) "$n" "$base" "$conv_type"
            last_global_pct=$global_pct
          fi
        fi
      done
      cmd_exit_code=$?
      set -e
      (( cmd_exit_code == 0 )) && conversion_success=1
      ;;
    *)
      # CD/GDI conversion
      set +e
      chdman createcd -c "cdzs,cdzl,cdfl" -i "$src" -o "$out" 2>&1 | while IFS= read -r line; do
        if [[ "$line" =~ ([0-9]{1,3})% ]]; then
          p="${BASH_REMATCH[1]}"
          (( p > 100 )) && p=100
          now=$(date +%s); elapsed=$(( now - start_ts ))
          prog_bytes=$(( done_bytes + fbytes*p/100 ))
          global_pct=$(( (prog_bytes*100)/total_bytes ))
          if (( global_pct != last_global_pct )); then
            eta=$(( prog_bytes > 0 ? elapsed * (total_bytes - prog_bytes) / prog_bytes : 0 ))
            print_bar "$global_pct" "$prog_bytes" "$total_bytes" "$eta" $((i+1)) "$n" "$base" "$conv_type"
            last_global_pct=$global_pct
          fi
        fi
      done
      cmd_exit_code=$?
      set -e
      (( cmd_exit_code == 0 )) && conversion_success=1
      ;;
  esac

  if (( conversion_success )); then
    done_bytes=$(( done_bytes + fbytes ))
  else
    FAILED_CONVERSIONS+=("$src")
    # Remove partial output file if it exists
    [[ -f "$out" ]] && rm -f "$out"
  fi
  
  now=$(date +%s); prog_bytes=$done_bytes
  global_pct=$(( (prog_bytes*100)/total_bytes ))
  print_bar "$global_pct" "$prog_bytes" "$total_bytes" 0 $((i+1)) "$n" "$base" "$conv_type"
done

# Clear trap since we're handling results manually now
trap - EXIT
show_results
